{"version":3,"file":"static/chunks/6737-9745982011420f0a.js","mappings":"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","sources":["webpack://_N_E/./src/config/constants/nftsCollections/delist.ts","webpack://_N_E/./src/state/nftMarket/queries.ts","webpack://_N_E/./src/state/nftMarket/helpers.ts","webpack://_N_E/./src/state/nftMarket/types.ts","webpack://_N_E/<anon>"],"sourcesContent":["const DELIST_COLLECTIONS = {\n  '0x4D89eBf7b1F66806A4C99Df71D22b7b9efC6bB0b': {\n    active: false,\n    address: '0x4D89eBf7b1F66806A4C99Df71D22b7b9efC6bB0b',\n    avatar: '',\n    banner: {\n      large: '',\n      small: '',\n    },\n    createdAt: '',\n    creatorAddress: '',\n    creatorFee: '',\n    description: '',\n    id: '0x4d89ebf7b1f66806a4c99df71d22b7b9efc6bb0b',\n    name: 'Baked Potatoes',\n    numberTokensListed: '76',\n    owner: '0xCd1B0abBc3E55E91FCC5AEE393525e68478C2952',\n    symbol: 'POT',\n    totalSupply: '',\n    totalTrades: '',\n    totalVolumeBNB: '',\n    tradingFee: '',\n    updatedAt: '',\n    verified: true,\n    whitelistChecker: '',\n  },\n  '0xC448498DDC536ad6F5d437325725dCf504d2d964': {\n    active: false,\n    address: '0xC448498DDC536ad6F5d437325725dCf504d2d964',\n    avatar: '',\n    banner: {\n      large: '',\n      small: '',\n    },\n    createdAt: '',\n    creatorAddress: '',\n    creatorFee: '',\n    description: '',\n    id: '0xC448498DDC536ad6F5d437325725dCf504d2d964',\n    name: 'Catbread',\n    numberTokensListed: '9385',\n    owner: '0xC9A81c56eb07397989907fa6BcC121B593d8f141',\n    symbol: 'CATBREADNFT',\n    totalSupply: '',\n    totalTrades: '',\n    totalVolumeBNB: '',\n    tradingFee: '',\n    updatedAt: '',\n    verified: true,\n    whitelistChecker: '',\n  },\n  '0x44d85770aEa263F9463418708125Cd95e308299B': {\n    active: false,\n    address: '0x44d85770aEa263F9463418708125Cd95e308299B',\n    avatar: '',\n    banner: {\n      large: '',\n      small: '',\n    },\n    createdAt: '',\n    creatorAddress: '',\n    creatorFee: '',\n    description: '',\n    id: '0x44d85770aEa263F9463418708125Cd95e308299B',\n    name: 'BornBadBoys',\n    numberTokensListed: '1846',\n    owner: '0x952B8A6AC7957B769C6cAD934b128f2d27368565',\n    symbol: 'BBB',\n    totalSupply: '',\n    totalTrades: '',\n    totalVolumeBNB: '',\n    tradingFee: '',\n    updatedAt: '',\n    verified: true,\n    whitelistChecker: '',\n  },\n}\n\nexport default DELIST_COLLECTIONS\n","export const baseNftFields = `\n  tokenId\n  metadataUrl\n  currentAskPrice\n  currentSeller\n  latestTradedPriceInBNB\n  tradeVolumeBNB\n  totalTrades\n  isTradable\n  updatedAt\n  otherId\n  collection {\n    id\n  }\n`\n\nexport const baseTransactionFields = `\n  id\n  block\n  timestamp\n  askPrice\n  netPrice\n  withBNB\n  buyer {\n    id\n  }\n  seller {\n    id\n  }\n`\n\nexport const collectionBaseFields = `\n  id\n  name\n  symbol\n  active\n  totalTrades\n  totalVolumeBNB\n  numberTokensListed\n  creatorAddress\n  tradingFee\n  creatorFee\n  whitelistChecker\n`\n","import { gql, request } from 'graphql-request'\nimport { stringify } from 'querystring'\nimport { API_NFT, GRAPH_API_NFTMARKET } from 'config/constants/endpoints'\nimport { multicallv2 } from 'utils/multicall'\nimport { isAddress } from 'utils'\nimport erc721Abi from 'config/abi/erc721.json'\nimport range from 'lodash/range'\nimport groupBy from 'lodash/groupBy'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { getNftMarketContract } from 'utils/contractHelpers'\nimport { NOT_ON_SALE_SELLER } from 'config/constants'\nimport DELIST_COLLECTIONS from 'config/constants/nftsCollections/delist'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport { formatBigNumber } from '@pancakeswap/utils/formatBalance'\nimport { getNftMarketAddress } from 'utils/addressHelpers'\nimport nftMarketAbi from 'config/abi/nftMarket.json'\nimport fromPairs from 'lodash/fromPairs'\nimport pickBy from 'lodash/pickBy'\nimport lodashSize from 'lodash/size'\nimport {\n  ApiCollection,\n  ApiCollections,\n  ApiResponseCollectionTokens,\n  ApiResponseSpecificToken,\n  AskOrderType,\n  Collection,\n  CollectionMarketDataBaseFields,\n  NftActivityFilter,\n  NftLocation,\n  NftToken,\n  TokenIdWithCollectionAddress,\n  TokenMarketData,\n  Transaction,\n  AskOrder,\n  ApiSingleTokenData,\n  NftAttribute,\n  ApiTokenFilterResponse,\n  ApiCollectionsResponse,\n  MarketEvent,\n  UserActivity,\n} from './types'\nimport { baseNftFields, collectionBaseFields, baseTransactionFields } from './queries'\n\n/**\n * API HELPERS\n */\n\n/**\n * Fetch static data from all collections using the API\n * @returns\n */\nexport const getCollectionsApi = async (): Promise<ApiCollectionsResponse> => {\n  const res = await fetch(`${API_NFT}/collections`)\n  if (res.ok) {\n    const json = await res.json()\n    return json\n  }\n  console.error('Failed to fetch NFT collections', res.statusText)\n  return null\n}\n\nconst fetchCollectionsTotalSupply = async (collections: ApiCollection[]): Promise<number[]> => {\n  const totalSupplyCalls = collections\n    .filter((collection) => collection?.address)\n    .map((collection) => ({\n      address: collection.address.toLowerCase(),\n      name: 'totalSupply',\n    }))\n  if (totalSupplyCalls.length > 0) {\n    const totalSupplyRaw = await multicallv2({\n      abi: erc721Abi,\n      calls: totalSupplyCalls,\n      options: { requireSuccess: false },\n    })\n    const totalSupply = totalSupplyRaw.flat()\n    return totalSupply.map((totalCount) => (totalCount ? totalCount.toNumber() : 0))\n  }\n  return []\n}\n\n/**\n * Fetch all collections data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */\nexport const getCollections = async (): Promise<Record<string, Collection>> => {\n  try {\n    const [collections, collectionsMarket] = await Promise.all([getCollectionsApi(), getCollectionsSg()])\n    const collectionApiData: ApiCollection[] = collections?.data ?? []\n    const collectionsTotalSupply = await fetchCollectionsTotalSupply(collectionApiData)\n    const collectionApiDataCombinedOnChain = collectionApiData.map((collection, index) => {\n      const totalSupplyFromApi = Number(collection?.totalSupply) || 0\n      const totalSupplyFromOnChain = collectionsTotalSupply[index]\n      return {\n        ...collection,\n        totalSupply: Math.max(totalSupplyFromApi, totalSupplyFromOnChain).toString(),\n      }\n    })\n\n    return combineCollectionData(collectionApiDataCombinedOnChain, collectionsMarket)\n  } catch (error) {\n    console.error('Unable to fetch data:', error)\n    return null\n  }\n}\n\n/**\n * Fetch collection data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */\nexport const getCollection = async (collectionAddress: string): Promise<Record<string, Collection> | null> => {\n  try {\n    const [collection, collectionMarket] = await Promise.all([\n      getCollectionApi(collectionAddress),\n      getCollectionSg(collectionAddress),\n    ])\n\n    const collectionsTotalSupply = await fetchCollectionsTotalSupply([collection])\n    const totalSupplyFromApi = Number(collection?.totalSupply) || 0\n    const totalSupplyFromOnChain = collectionsTotalSupply[0]\n    const collectionApiDataCombinedOnChain = {\n      ...collection,\n      totalSupply: Math.max(totalSupplyFromApi, totalSupplyFromOnChain).toString(),\n    }\n\n    return combineCollectionData([collectionApiDataCombinedOnChain], [collectionMarket])\n  } catch (error) {\n    console.error('Unable to fetch data:', error)\n    return null\n  }\n}\n\n/**\n * Fetch static data from a collection using the API\n * @returns\n */\nexport const getCollectionApi = async (collectionAddress: string): Promise<ApiCollection> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}`)\n  if (res.ok) {\n    const json = await res.json()\n    return json.data\n  }\n  console.error(`API: Failed to fetch NFT collection ${collectionAddress}`, res.statusText)\n  return null\n}\n\n/**\n * Fetch static data for all nfts in a collection using the API\n * @param collectionAddress\n * @param size\n * @param page\n * @returns\n */\nexport const getNftsFromCollectionApi = async (\n  collectionAddress: string,\n  size = 100,\n  page = 1,\n): Promise<ApiResponseCollectionTokens> => {\n  const isPBCollection = isAddress(collectionAddress) === pancakeBunniesAddress\n  const requestPath = `${API_NFT}/collections/${collectionAddress}/tokens${\n    !isPBCollection ? `?page=${page}&size=${size}` : ``\n  }`\n\n  try {\n    const res = await fetch(requestPath)\n    if (res.ok) {\n      const data = await res.json()\n      const filteredAttributesDistribution = pickBy(data.attributesDistribution, Boolean)\n      const filteredData = pickBy(data.data, Boolean)\n      const filteredTotal = lodashSize(filteredData)\n      return {\n        ...data,\n        total: filteredTotal,\n        attributesDistribution: filteredAttributesDistribution,\n        data: filteredData,\n      }\n    }\n    console.error(`API: Failed to fetch NFT tokens for ${collectionAddress} collection`, res.statusText)\n    return null\n  } catch (error) {\n    console.error(`API: Failed to fetch NFT tokens for ${collectionAddress} collection`, error)\n    return null\n  }\n}\n\n/**\n * Fetch a single NFT using the API\n * @param collectionAddress\n * @param tokenId\n * @returns NFT from API\n */\nexport const getNftApi = async (\n  collectionAddress: string,\n  tokenId: string,\n): Promise<ApiResponseSpecificToken['data']> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/tokens/${tokenId}`)\n  if (res.ok) {\n    const json = await res.json()\n    return json.data\n  }\n\n  console.error(`API: Can't fetch NFT token ${tokenId} in ${collectionAddress}`, res.status)\n  return null\n}\n\n/**\n * Fetch a list of NFT from different collections\n * @param from Array of { collectionAddress: string; tokenId: string }\n * @returns Array of NFT from API\n */\nexport const getNftsFromDifferentCollectionsApi = async (\n  from: { collectionAddress: string; tokenId: string }[],\n): Promise<NftToken[]> => {\n  const promises = from.map((nft) => getNftApi(nft.collectionAddress, nft.tokenId))\n  const responses = await Promise.all(promises)\n  // Sometimes API can't find some tokens (e.g. 404 response)\n  // at least return the ones that returned successfully\n  return responses\n    .filter((resp) => resp)\n    .map((res, index) => ({\n      tokenId: res.tokenId,\n      name: res.name,\n      collectionName: res.collection.name,\n      collectionAddress: from[index].collectionAddress,\n      description: res.description,\n      attributes: res.attributes,\n      createdAt: res.createdAt,\n      updatedAt: res.updatedAt,\n      image: res.image,\n    }))\n}\n\n/**\n * SUBGRAPH HELPERS\n */\n\n/**\n * Fetch market data from a collection using the Subgraph\n * @returns\n */\nexport const getCollectionSg = async (collectionAddress: string): Promise<CollectionMarketDataBaseFields> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getCollectionData($collectionAddress: String!) {\n          collection(id: $collectionAddress) {\n            ${collectionBaseFields}\n          }\n        }\n      `,\n      { collectionAddress: collectionAddress.toLowerCase() },\n    )\n    return res.collection\n  } catch (error) {\n    console.error('Failed to fetch collection', error)\n    return null\n  }\n}\n\n/**\n * Fetch market data from all collections using the Subgraph\n * @returns\n */\nexport const getCollectionsSg = async (): Promise<CollectionMarketDataBaseFields[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        {\n          collections {\n            ${collectionBaseFields}\n          }\n        }\n      `,\n    )\n    return res.collections\n  } catch (error) {\n    console.error('Failed to fetch NFT collections', error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for nfts in a collection using the Subgraph\n * @param collectionAddress\n * @param first\n * @param skip\n * @returns\n */\nexport const getNftsFromCollectionSg = async (\n  collectionAddress: string,\n  first = 1000,\n  skip = 0,\n): Promise<TokenMarketData[]> => {\n  // Squad to be sorted by tokenId as this matches the order of the paginated API return. For PBs - get the most recent,\n  const isPBCollection = isAddress(collectionAddress) === pancakeBunniesAddress\n\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftCollectionMarketData($collectionAddress: String!) {\n          collection(id: $collectionAddress) {\n            id\n            nfts(orderBy:${isPBCollection ? 'updatedAt' : 'tokenId'}, skip: $skip, first: $first) {\n             ${baseNftFields}\n            }\n          }\n        }\n      `,\n      { collectionAddress: collectionAddress.toLowerCase(), skip, first },\n    )\n    return res.collection.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs from collection', error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */\nexport const getNftsByBunnyIdSg = async (\n  bunnyId: string,\n  existingTokenIds: string[],\n  orderDirection: 'asc' | 'desc',\n): Promise<TokenMarketData[]> => {\n  try {\n    const where =\n      existingTokenIds.length > 0\n        ? { otherId: bunnyId, isTradable: true, tokenId_not_in: existingTokenIds }\n        : { otherId: bunnyId, isTradable: true }\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftsByBunnyIdSg($collectionAddress: String!, $where: NFT_filter, $orderDirection: String!) {\n          nfts(first: 30, where: $where, orderBy: currentAskPrice, orderDirection: $orderDirection) {\n            ${baseNftFields}\n          }\n        }\n      `,\n      {\n        collectionAddress: pancakeBunniesAddress.toLowerCase(),\n        where,\n        orderDirection,\n      },\n    )\n    return res.nfts\n  } catch (error) {\n    console.error(`Failed to fetch collection NFTs for bunny id ${bunnyId}`, error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */\nexport const getMarketDataForTokenIds = async (\n  collectionAddress: string,\n  existingTokenIds: string[],\n): Promise<TokenMarketData[]> => {\n  try {\n    if (existingTokenIds.length === 0) {\n      return []\n    }\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getMarketDataForTokenIds($collectionAddress: String!, $where: NFT_filter) {\n          collection(id: $collectionAddress) {\n            id\n            nfts(first: 1000, where: $where) {\n              ${baseNftFields}\n            }\n          }\n        }\n      `,\n      {\n        collectionAddress: collectionAddress.toLowerCase(),\n        where: { tokenId_in: existingTokenIds },\n      },\n    )\n    return res.collection.nfts\n  } catch (error) {\n    console.error(`Failed to fetch market data for NFTs stored tokens`, error)\n    return []\n  }\n}\n\nexport const getNftsOnChainMarketData = async (\n  collectionAddress: string,\n  tokenIds: string[],\n): Promise<TokenMarketData[]> => {\n  try {\n    const nftMarketContract = getNftMarketContract()\n    const response = await nftMarketContract.viewAsksByCollectionAndTokenIds(collectionAddress.toLowerCase(), tokenIds)\n    const askInfo = response?.askInfo\n\n    if (!askInfo) return []\n\n    return askInfo\n      .map((tokenAskInfo, index) => {\n        if (!tokenAskInfo.seller || !tokenAskInfo.price) return null\n        const currentSeller = tokenAskInfo.seller\n        const isTradable = currentSeller.toLowerCase() !== NOT_ON_SALE_SELLER\n        const currentAskPrice = tokenAskInfo.price && formatBigNumber(tokenAskInfo.price)\n\n        return {\n          collection: { id: collectionAddress.toLowerCase() },\n          tokenId: tokenIds[index],\n          currentSeller,\n          isTradable,\n          currentAskPrice,\n        }\n      })\n      .filter(Boolean)\n  } catch (error) {\n    console.error('Failed to fetch NFTs onchain market data', error)\n    return []\n  }\n}\n\nexport const getNftsUpdatedMarketData = async (\n  collectionAddress: string,\n  tokenIds: string[],\n): Promise<{ tokenId: string; currentSeller: string; currentAskPrice: BigNumber; isTradable: boolean }[]> => {\n  try {\n    const nftMarketContract = getNftMarketContract()\n    const response = await nftMarketContract.viewAsksByCollectionAndTokenIds(collectionAddress.toLowerCase(), tokenIds)\n    const askInfo = response?.askInfo\n\n    if (!askInfo) return null\n\n    return askInfo.map((tokenAskInfo, index) => {\n      const isTradable = tokenAskInfo.seller ? tokenAskInfo.seller.toLowerCase() !== NOT_ON_SALE_SELLER : false\n\n      return {\n        tokenId: tokenIds[index],\n        currentSeller: tokenAskInfo.seller,\n        isTradable,\n        currentAskPrice: tokenAskInfo.price,\n      }\n    })\n  } catch (error) {\n    console.error('Failed to fetch updated NFT market data', error)\n    return null\n  }\n}\n\nexport const getAccountNftsOnChainMarketData = async (\n  collections: ApiCollections,\n  account: string,\n): Promise<TokenMarketData[]> => {\n  try {\n    const nftMarketAddress = getNftMarketAddress()\n    const collectionList = Object.values(collections)\n    const askCalls = collectionList.map((collection) => {\n      const { address: collectionAddress } = collection\n      return {\n        address: nftMarketAddress,\n        name: 'viewAsksByCollectionAndSeller',\n        params: [collectionAddress, account, 0, 1000],\n      }\n    })\n\n    const askCallsResultsRaw = await multicallv2({\n      abi: nftMarketAbi,\n      calls: askCalls,\n      options: { requireSuccess: false },\n    })\n    const askCallsResults = askCallsResultsRaw\n      .map((askCallsResultRaw, askCallIndex) => {\n        if (!askCallsResultRaw?.tokenIds || !askCallsResultRaw?.askInfo || !collectionList[askCallIndex]?.address)\n          return null\n        return askCallsResultRaw.tokenIds\n          .map((tokenId, tokenIdIndex) => {\n            if (!tokenId || !askCallsResultRaw.askInfo[tokenIdIndex] || !askCallsResultRaw.askInfo[tokenIdIndex].price)\n              return null\n\n            const currentAskPrice = formatBigNumber(askCallsResultRaw.askInfo[tokenIdIndex].price)\n\n            return {\n              collection: { id: collectionList[askCallIndex].address.toLowerCase() },\n              tokenId: tokenId.toString(),\n              account,\n              isTradable: true,\n              currentAskPrice,\n            }\n          })\n          .filter(Boolean)\n      })\n      .flat()\n      .filter(Boolean)\n\n    return askCallsResults\n  } catch (error) {\n    console.error('Failed to fetch NFTs onchain market data', error)\n    return []\n  }\n}\n\nexport const getNftsMarketData = async (\n  where = {},\n  first = 1000,\n  orderBy = 'id',\n  orderDirection: 'asc' | 'desc' = 'desc',\n  skip = 0,\n): Promise<TokenMarketData[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftsMarketData($first: Int, $skip: Int!, $where: NFT_filter, $orderBy: NFT_orderBy, $orderDirection: OrderDirection) {\n          nfts(where: $where, first: $first, orderBy: $orderBy, orderDirection: $orderDirection, skip: $skip) {\n            ${baseNftFields}\n            transactionHistory {\n              ${baseTransactionFields}\n            }\n          }\n        }\n      `,\n      { where, first, skip, orderBy, orderDirection },\n    )\n\n    return res.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs market data', error)\n    return []\n  }\n}\n\nexport const getAllPancakeBunniesLowestPrice = async (bunnyIds: string[]): Promise<Record<string, number>> => {\n  try {\n    const singlePancakeBunnySubQueries = bunnyIds.map(\n      (\n        bunnyId,\n      ) => `b${bunnyId}:nfts(first: 1, where: { otherId: ${bunnyId}, isTradable: true }, orderBy: currentAskPrice, orderDirection: asc) {\n        currentAskPrice\n      }\n    `,\n    )\n    const rawResponse: Record<string, { currentAskPrice: string }[]> = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getAllPancakeBunniesLowestPrice {\n          ${singlePancakeBunnySubQueries}\n        }\n      `,\n    )\n    return fromPairs(\n      Object.keys(rawResponse).map((subQueryKey) => {\n        const bunnyId = subQueryKey.split('b')[1]\n        return [\n          bunnyId,\n          rawResponse[subQueryKey].length > 0 ? parseFloat(rawResponse[subQueryKey][0].currentAskPrice) : Infinity,\n        ]\n      }),\n    )\n  } catch (error) {\n    console.error('Failed to fetch PancakeBunnies lowest prices', error)\n    return {}\n  }\n}\n\nexport const getAllPancakeBunniesRecentUpdatedAt = async (bunnyIds: string[]): Promise<Record<string, number>> => {\n  try {\n    const singlePancakeBunnySubQueries = bunnyIds.map(\n      (\n        bunnyId,\n      ) => `b${bunnyId}:nfts(first: 1, where: { otherId: ${bunnyId}, isTradable: true }, orderBy: updatedAt, orderDirection: desc) {\n        updatedAt\n      }\n    `,\n    )\n    const rawResponse: Record<string, { updatedAt: string }[]> = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getAllPancakeBunniesLowestPrice {\n          ${singlePancakeBunnySubQueries}\n        }\n      `,\n    )\n    return fromPairs(\n      Object.keys(rawResponse).map((subQueryKey) => {\n        const bunnyId = subQueryKey.split('b')[1]\n        return [\n          bunnyId,\n          rawResponse[subQueryKey].length > 0 ? Number(rawResponse[subQueryKey][0].updatedAt) : -Infinity,\n        ]\n      }),\n    )\n  } catch (error) {\n    console.error('Failed to fetch PancakeBunnies latest market updates', error)\n    return {}\n  }\n}\n\n/**\n * Returns the lowest/highest price of any NFT in a collection\n */\nexport const getLeastMostPriceInCollection = async (\n  collectionAddress: string,\n  orderDirection: 'asc' | 'desc' = 'asc',\n) => {\n  try {\n    const response = await getNftsMarketData(\n      { collection: collectionAddress.toLowerCase(), isTradable: true },\n      1,\n      'currentAskPrice',\n      orderDirection,\n    )\n\n    if (response.length === 0) {\n      return 0\n    }\n\n    const [nftSg] = response\n    return parseFloat(nftSg.currentAskPrice)\n  } catch (error) {\n    console.error(`Failed to lowest price NFTs in collection ${collectionAddress}`, error)\n    return 0\n  }\n}\n\n/**\n * Fetch user trading data for buyTradeHistory, sellTradeHistory and askOrderHistory from the Subgraph\n * @param where a User_filter where condition\n * @returns a UserActivity object\n */\nexport const getUserActivity = async (address: string): Promise<UserActivity> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getUserActivity($address: String!) {\n          user(id: $address) {\n            buyTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\n              ${baseTransactionFields}\n              nft {\n                ${baseNftFields}\n              }\n            }\n            sellTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\n              ${baseTransactionFields}\n              nft {\n                ${baseNftFields}\n              }\n            }\n            askOrderHistory(first: 500, orderBy: timestamp, orderDirection: desc) {\n              id\n              block\n              timestamp\n              orderType\n              askPrice\n              nft {\n                ${baseNftFields}\n              }\n            }\n          }\n        }\n      `,\n      { address },\n    )\n\n    return res.user || { askOrderHistory: [], buyTradeHistory: [], sellTradeHistory: [] }\n  } catch (error) {\n    console.error('Failed to fetch user Activity', error)\n    return {\n      askOrderHistory: [],\n      buyTradeHistory: [],\n      sellTradeHistory: [],\n    }\n  }\n}\n\nexport const getCollectionActivity = async (\n  address: string,\n  nftActivityFilter: NftActivityFilter,\n  itemPerQuery,\n): Promise<{ askOrders?: AskOrder[]; transactions?: Transaction[] }> => {\n  const getAskOrderEvent = (orderType: MarketEvent): AskOrderType => {\n    switch (orderType) {\n      case MarketEvent.CANCEL:\n        return AskOrderType.CANCEL\n      case MarketEvent.MODIFY:\n        return AskOrderType.MODIFY\n      case MarketEvent.NEW:\n        return AskOrderType.NEW\n      default:\n        return AskOrderType.MODIFY\n    }\n  }\n\n  const isFetchAllCollections = address === ''\n\n  const hasCollectionFilter = nftActivityFilter.collectionFilters.length > 0\n\n  const collectionFilterGql = !isFetchAllCollections\n    ? `collection: ${JSON.stringify(address)}`\n    : hasCollectionFilter\n    ? `collection_in: ${JSON.stringify(nftActivityFilter.collectionFilters)}`\n    : ``\n\n  const askOrderTypeFilter = nftActivityFilter.typeFilters\n    .filter((marketEvent) => marketEvent !== MarketEvent.SELL)\n    .map((marketEvent) => getAskOrderEvent(marketEvent))\n\n  const askOrderIncluded = nftActivityFilter.typeFilters.length === 0 || askOrderTypeFilter.length > 0\n\n  const askOrderTypeFilterGql =\n    askOrderTypeFilter.length > 0 ? `orderType_in: ${JSON.stringify(askOrderTypeFilter)}` : ``\n\n  const transactionIncluded =\n    nftActivityFilter.typeFilters.length === 0 ||\n    nftActivityFilter.typeFilters.some(\n      (marketEvent) => marketEvent === MarketEvent.BUY || marketEvent === MarketEvent.SELL,\n    )\n\n  let askOrderQueryItem = itemPerQuery / 2\n  let transactionQueryItem = itemPerQuery / 2\n\n  if (!askOrderIncluded || !transactionIncluded) {\n    askOrderQueryItem = !askOrderIncluded ? 0 : itemPerQuery\n    transactionQueryItem = !transactionIncluded ? 0 : itemPerQuery\n  }\n\n  const askOrderGql = askOrderIncluded\n    ? `askOrders(first: ${askOrderQueryItem}, orderBy: timestamp, orderDirection: desc, where:{\n            ${collectionFilterGql}, ${askOrderTypeFilterGql}\n          }) {\n              id\n              block\n              timestamp\n              orderType\n              askPrice\n              seller {\n                id\n              }\n              nft {\n                ${baseNftFields}\n              }\n          }`\n    : ``\n\n  const transactionGql = transactionIncluded\n    ? `transactions(first: ${transactionQueryItem}, orderBy: timestamp, orderDirection: desc, where:{\n            ${collectionFilterGql}\n          }) {\n            ${baseTransactionFields}\n              nft {\n                ${baseNftFields}\n              }\n          }`\n    : ``\n\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getCollectionActivity {\n          ${askOrderGql}\n          ${transactionGql}\n        }\n      `,\n    )\n\n    return res || { askOrders: [], transactions: [] }\n  } catch (error) {\n    console.error('Failed to fetch collection Activity', error)\n    return {\n      askOrders: [],\n      transactions: [],\n    }\n  }\n}\n\nexport const getTokenActivity = async (\n  tokenId: string,\n  collectionAddress: string,\n): Promise<{ askOrders: AskOrder[]; transactions: Transaction[] }> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getCollectionActivity($tokenId: BigInt!, $address: ID!) {\n          nfts(where:{tokenId: $tokenId, collection: $address}) {\n            transactionHistory(orderBy: timestamp, orderDirection: desc) {\n              ${baseTransactionFields}\n                nft {\n                  ${baseNftFields}\n                }\n            }\n            askHistory(orderBy: timestamp, orderDirection: desc) {\n                id\n                block\n                timestamp\n                orderType\n                askPrice\n                seller {\n                  id\n                }\n                nft {\n                  ${baseNftFields}\n                }\n            }\n          }\n        }\n      `,\n      { tokenId, address: collectionAddress },\n    )\n\n    if (res.nfts.length > 0) {\n      return { askOrders: res.nfts[0].askHistory, transactions: res.nfts[0].transactionHistory }\n    }\n    return { askOrders: [], transactions: [] }\n  } catch (error) {\n    console.error('Failed to fetch token Activity', error)\n    return {\n      askOrders: [],\n      transactions: [],\n    }\n  }\n}\n\n/**\n * Get the most recently listed NFTs\n * @param first Number of nfts to retrieve\n * @returns NftTokenSg[]\n */\nexport const getLatestListedNfts = async (first: number): Promise<TokenMarketData[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getLatestNftMarketData($first: Int) {\n          nfts(where: { isTradable: true }, orderBy: updatedAt , orderDirection: desc, first: $first) {\n            ${baseNftFields}\n            collection {\n              id\n            }\n          }\n        }\n      `,\n      { first },\n    )\n\n    return res.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs market data', error)\n    return []\n  }\n}\n\n/**\n * Filter NFTs from a collection\n * @param collectionAddress\n * @returns\n */\nexport const fetchNftsFiltered = async (\n  collectionAddress: string,\n  filters: Record<string, string | number>,\n): Promise<ApiTokenFilterResponse> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/filter?${stringify(filters)}`)\n\n  if (res.ok) {\n    const data = await res.json()\n    return data\n  }\n\n  console.error(`API: Failed to fetch NFT collection ${collectionAddress}`, res.statusText)\n  return null\n}\n\n/**\n * OTHER HELPERS\n */\n\nexport const getMetadataWithFallback = (apiMetadata: ApiResponseCollectionTokens['data'], bunnyId: string) => {\n  // The fallback is just for the testnet where some bunnies don't exist\n  return (\n    apiMetadata[bunnyId] ?? {\n      name: '',\n      description: '',\n      collection: { name: 'Pancake Bunnies' },\n      image: {\n        original: '',\n        thumbnail: '',\n      },\n    }\n  )\n}\n\nexport const getPancakeBunniesAttributesField = (bunnyId: string) => {\n  // Generating attributes field that is not returned by API\n  // but can be \"faked\" since objects are keyed with bunny id\n  return [\n    {\n      traitType: 'bunnyId',\n      value: bunnyId,\n      displayType: null,\n    },\n  ]\n}\n\nexport const combineApiAndSgResponseToNftToken = (\n  apiMetadata: ApiSingleTokenData,\n  marketData: TokenMarketData,\n  attributes: NftAttribute[],\n) => {\n  return {\n    tokenId: marketData.tokenId,\n    name: apiMetadata.name,\n    description: apiMetadata.description,\n    collectionName: apiMetadata.collection.name,\n    collectionAddress: pancakeBunniesAddress,\n    image: apiMetadata.image,\n    marketData,\n    attributes,\n  }\n}\n\nexport const fetchWalletTokenIdsForCollections = async (\n  account: string,\n  collections: ApiCollections,\n): Promise<TokenIdWithCollectionAddress[]> => {\n  const balanceOfCalls = Object.values(collections).map((collection) => {\n    const { address: collectionAddress } = collection\n    return {\n      address: collectionAddress,\n      name: 'balanceOf',\n      params: [account],\n    }\n  })\n\n  const balanceOfCallsResultRaw = await multicallv2({\n    abi: erc721Abi,\n    calls: balanceOfCalls,\n    options: { requireSuccess: false },\n  })\n  const balanceOfCallsResult = balanceOfCallsResultRaw.flat()\n\n  const tokenIdCalls = Object.values(collections)\n    .map((collection, index) => {\n      const balanceOf = balanceOfCallsResult[index]?.toNumber() ?? 0\n      const { address: collectionAddress } = collection\n\n      return range(balanceOf).map((tokenIndex) => {\n        return {\n          address: collectionAddress,\n          name: 'tokenOfOwnerByIndex',\n          params: [account, tokenIndex],\n        }\n      })\n    })\n    .flat()\n\n  const tokenIdResultRaw = await multicallv2({\n    abi: erc721Abi,\n    calls: tokenIdCalls,\n    options: { requireSuccess: false },\n  })\n  const tokenIdResult = tokenIdResultRaw.flat()\n\n  const nftLocation = NftLocation.WALLET\n\n  const walletNfts = tokenIdResult.reduce((acc, tokenIdBn, index) => {\n    if (tokenIdBn) {\n      const { address: collectionAddress } = tokenIdCalls[index]\n      acc.push({ tokenId: tokenIdBn.toString(), collectionAddress, nftLocation })\n    }\n    return acc\n  }, [])\n\n  return walletNfts\n}\n\n/**\n * Helper to combine data from the collections' API and subgraph\n */\nexport const combineCollectionData = (\n  collectionApiData: ApiCollection[],\n  collectionSgData: CollectionMarketDataBaseFields[],\n): Record<string, Collection> => {\n  const collectionsMarketObj: Record<string, CollectionMarketDataBaseFields> = fromPairs(\n    collectionSgData.map((current) => [current.id, current]),\n  )\n\n  return fromPairs(\n    collectionApiData\n      .filter((collection) => collection?.address)\n      .map((current) => {\n        const collectionMarket = collectionsMarketObj[current.address.toLowerCase()]\n        const collection: Collection = {\n          ...current,\n          ...collectionMarket,\n        }\n\n        if (current.name) {\n          collection.name = current.name\n        }\n\n        return [current.address, collection]\n      }),\n  )\n}\n\n/**\n * Evaluate whether a market NFT is in a users wallet, their profile picture, or on sale\n * @param tokenId string\n * @param tokenIdsInWallet array of tokenIds in wallet\n * @param tokenIdsForSale array of tokenIds on sale\n * @param profileNftId Optional tokenId of users' profile picture\n * @returns NftLocation enum value\n */\nexport const getNftLocationForMarketNft = (\n  tokenId: string,\n  tokenIdsInWallet: string[],\n  tokenIdsForSale: string[],\n  profileNftId?: string,\n): NftLocation => {\n  if (tokenId === profileNftId) {\n    return NftLocation.PROFILE\n  }\n  if (tokenIdsForSale.includes(tokenId)) {\n    return NftLocation.FORSALE\n  }\n  if (tokenIdsInWallet.includes(tokenId)) {\n    return NftLocation.WALLET\n  }\n  console.error(`Cannot determine location for tokenID ${tokenId}, defaulting to NftLocation.WALLET`)\n  return NftLocation.WALLET\n}\n\n/**\n * Construct complete TokenMarketData entities with a users' wallet NFT ids and market data for their wallet NFTs\n * @param walletNfts TokenIdWithCollectionAddress\n * @param marketDataForWalletNfts TokenMarketData[]\n * @returns TokenMarketData[]\n */\nexport const attachMarketDataToWalletNfts = (\n  walletNfts: TokenIdWithCollectionAddress[],\n  marketDataForWalletNfts: TokenMarketData[],\n): TokenMarketData[] => {\n  const walletNftsWithMarketData = walletNfts.map((walletNft) => {\n    const marketData = marketDataForWalletNfts.find(\n      (marketNft) =>\n        marketNft.tokenId === walletNft.tokenId &&\n        marketNft.collection.id.toLowerCase() === walletNft.collectionAddress.toLowerCase(),\n    )\n    return (\n      marketData ?? {\n        tokenId: walletNft.tokenId,\n        collection: {\n          id: walletNft.collectionAddress.toLowerCase(),\n        },\n        nftLocation: walletNft.nftLocation,\n        metadataUrl: null,\n        transactionHistory: null,\n        currentSeller: null,\n        isTradable: null,\n        currentAskPrice: null,\n        latestTradedPriceInBNB: null,\n        tradeVolumeBNB: null,\n        totalTrades: null,\n        otherId: null,\n      }\n    )\n  })\n  return walletNftsWithMarketData\n}\n\n/**\n * Attach TokenMarketData and location to NftToken\n * @param nftsWithMetadata NftToken[] with API metadata\n * @param nftsForSale  market data for nfts that are on sale (i.e. not in a user's wallet)\n * @param walletNfts market data for nfts in a user's wallet\n * @param tokenIdsInWallet array of token ids in user's wallet\n * @param tokenIdsForSale array of token ids of nfts that are on sale\n * @param profileNftId profile picture token id\n * @returns NFT[]\n */\nexport const combineNftMarketAndMetadata = (\n  nftsWithMetadata: NftToken[],\n  nftsForSale: TokenMarketData[],\n  walletNfts: TokenMarketData[],\n  tokenIdsInWallet: string[],\n  tokenIdsForSale: string[],\n  profileNftId?: string,\n): NftToken[] => {\n  const completeNftData = nftsWithMetadata.map<NftToken>((nft) => {\n    // Get metadata object\n    let marketData = nftsForSale.find(\n      (forSaleNft) =>\n        forSaleNft.tokenId === nft.tokenId &&\n        forSaleNft.collection &&\n        forSaleNft.collection.id === nft.collectionAddress,\n    )\n    if (!marketData) {\n      marketData = walletNfts.find(\n        (marketNft) =>\n          marketNft.collection &&\n          marketNft.collection.id === nft.collectionAddress &&\n          marketNft.tokenId === nft.tokenId,\n      )\n    }\n    const location = getNftLocationForMarketNft(nft.tokenId, tokenIdsInWallet, tokenIdsForSale, profileNftId)\n    return { ...nft, marketData, location }\n  })\n  return completeNftData\n}\n\nconst fetchWalletMarketData = async (walletNftsByCollection: {\n  [collectionAddress: string]: TokenIdWithCollectionAddress[]\n}): Promise<TokenMarketData[]> => {\n  const walletMarketDataRequests = Object.entries(walletNftsByCollection).map(\n    async ([collectionAddress, tokenIdsWithCollectionAddress]) => {\n      const tokenIdIn = tokenIdsWithCollectionAddress.map((walletNft) => walletNft.tokenId)\n      const [nftsOnChainMarketData, nftsMarketData] = await Promise.all([\n        getNftsOnChainMarketData(collectionAddress.toLowerCase(), tokenIdIn),\n        getNftsMarketData({\n          tokenId_in: tokenIdIn,\n          collection: collectionAddress.toLowerCase(),\n        }),\n      ])\n\n      return tokenIdIn\n        .map((tokenId) => {\n          const nftMarketData = nftsMarketData.find((tokenMarketData) => tokenMarketData.tokenId === tokenId)\n          const onChainMarketData = nftsOnChainMarketData.find(\n            (onChainTokenMarketData) => onChainTokenMarketData.tokenId === tokenId,\n          )\n\n          if (!nftMarketData && !onChainMarketData) return null\n\n          return { ...nftMarketData, ...onChainMarketData }\n        })\n        .filter(Boolean)\n    },\n  )\n\n  const walletMarketDataResponses = await Promise.all(walletMarketDataRequests)\n  return walletMarketDataResponses.flat()\n}\n\n/**\n * Get in-wallet, on-sale & profile pic NFT metadata, complete with market data for a given account\n * @param account\n * @param collections\n * @param profileNftWithCollectionAddress\n * @returns Promise<NftToken[]>\n */\nexport const getCompleteAccountNftData = async (\n  account: string,\n  collections: ApiCollections,\n  profileNftWithCollectionAddress?: TokenIdWithCollectionAddress,\n): Promise<NftToken[]> => {\n  // Add delist collections to allow user reclaim their NFTs\n  const collectionsWithDelist = { ...collections, ...DELIST_COLLECTIONS }\n\n  const [walletNftIdsWithCollectionAddress, onChainForSaleNfts] = await Promise.all([\n    fetchWalletTokenIdsForCollections(account, collectionsWithDelist),\n    getAccountNftsOnChainMarketData(collectionsWithDelist, account),\n  ])\n\n  if (profileNftWithCollectionAddress?.tokenId) {\n    walletNftIdsWithCollectionAddress.unshift(profileNftWithCollectionAddress)\n  }\n\n  const walletNftsByCollection = groupBy(\n    walletNftIdsWithCollectionAddress,\n    (walletNftId) => walletNftId.collectionAddress,\n  )\n\n  const walletMarketData = await fetchWalletMarketData(walletNftsByCollection)\n\n  const walletNftsWithMarketData = attachMarketDataToWalletNfts(walletNftIdsWithCollectionAddress, walletMarketData)\n\n  const walletTokenIds = walletNftIdsWithCollectionAddress\n    .filter((walletNft) => {\n      // Profile Pic NFT is no longer wanted in this array, hence the filter\n      return profileNftWithCollectionAddress?.tokenId !== walletNft.tokenId\n    })\n    .map((nft) => nft.tokenId)\n\n  const tokenIdsForSale = onChainForSaleNfts.map((nft) => nft.tokenId)\n\n  const forSaleNftIds = onChainForSaleNfts.map((nft) => {\n    return { collectionAddress: nft.collection.id, tokenId: nft.tokenId }\n  })\n\n  const metadataForAllNfts = await getNftsFromDifferentCollectionsApi([\n    ...forSaleNftIds,\n    ...walletNftIdsWithCollectionAddress,\n  ])\n\n  const completeNftData = combineNftMarketAndMetadata(\n    metadataForAllNfts,\n    onChainForSaleNfts,\n    walletNftsWithMarketData,\n    walletTokenIds,\n    tokenIdsForSale,\n    profileNftWithCollectionAddress?.tokenId,\n  )\n\n  return completeNftData\n}\n\n/**\n * Fetch distribution information for a collection\n * @returns\n */\nexport const getCollectionDistributionApi = async <T>(collectionAddress: string): Promise<T> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/distribution`)\n  if (res.ok) {\n    const data = await res.json()\n    return data\n  }\n  console.error(`API: Failed to fetch NFT collection ${collectionAddress} distribution`, res.statusText)\n  return null\n}\n","import { BigNumberish } from '@ethersproject/bignumber'\n\n// Collections -> Nfts -> Transactions\n// Users -> Nft tokens IDs\n\nexport interface Transaction {\n  id: string\n  block: string\n  timestamp: string\n  askPrice: string\n  netPrice: string\n  buyer: { id: string }\n  seller: { id: string }\n  withBNB: boolean\n  nft?: TokenMarketData\n}\n\nexport enum AskOrderType {\n  NEW = 'New',\n  MODIFY = 'Modify',\n  CANCEL = 'Cancel',\n}\n\nexport interface AskOrder {\n  id: string\n  block: string\n  timestamp: string\n  askPrice: string\n  orderType: AskOrderType\n  nft?: TokenMarketData\n  seller?: { id: string }\n}\n\nexport interface Image {\n  original: string\n  thumbnail: string\n  mp4?: string\n  webm?: string\n  gif?: string\n}\n\nexport enum NftLocation {\n  FORSALE = 'For Sale',\n  PROFILE = 'Profile Pic',\n  WALLET = 'In Wallet',\n}\n\n// Market data regarding specific token ID, acquired via subgraph\nexport interface TokenMarketData {\n  tokenId: string\n  collection: {\n    id: string\n  }\n  currentAskPrice: string\n  currentSeller: string\n  isTradable: boolean\n  metadataUrl?: string\n  latestTradedPriceInBNB?: string\n  tradeVolumeBNB?: string\n  totalTrades?: string\n  otherId?: string\n  updatedAt?: string\n  transactionHistory?: Transaction[]\n}\n\n// Represents single NFT token, either Squad-like NFT or single PancakeBunny.\nexport interface NftToken {\n  tokenId: string\n  name: string\n  description: string\n  collectionName: string\n  collectionAddress: string\n  image: Image\n  attributes?: NftAttribute[]\n  createdAt?: string // API createdAt\n  updatedAt?: string // API updatedAt\n  marketData?: TokenMarketData\n  location?: NftLocation\n  meta?: Record<string, string | number>\n}\n\nexport interface NftFilter {\n  activeFilters: Record<string, NftAttribute>\n  showOnlyOnSale: boolean\n  ordering: {\n    field: string\n    direction: 'asc' | 'desc'\n  }\n}\n\nexport interface NftActivityFilter {\n  typeFilters: MarketEvent[]\n  collectionFilters: string[]\n}\n\nexport interface TokenIdWithCollectionAddress {\n  collectionAddress: string\n  tokenId: string\n  nftLocation?: NftLocation\n}\n\nexport interface NftAttribute {\n  traitType: string\n  value: string | number\n  displayType: string\n}\n\n// Internal type used to refer to a collection\n// Most fields are populated from API (via ApiCollection type)\nexport interface Collection {\n  id: string\n  address: string\n  name: string\n  createdAt?: string\n  description?: string\n  symbol: string\n  active: boolean\n  totalVolumeBNB: string\n  numberTokensListed: string\n  tradingFee: string\n  creatorFee: string\n  owner: string\n  totalSupply: string\n  verified: boolean\n  avatar: string\n  banner: {\n    large: string\n    small: string\n  }\n  attributes?: NftAttribute[]\n}\n\nexport interface ApiCollections {\n  [key: string]: Collection\n}\n\nexport interface User {\n  address: string\n  numberTokensListed: BigNumberish\n  numberTokensPurchased: BigNumberish\n  numberTokensSold: BigNumberish\n  nfts: Record<string, BigNumberish> // String is an address, BigNumberish is a tokenID\n}\n\n/**\n * API RESPONSES\n */\n\nexport interface ApiCollection {\n  address: string\n  owner: string\n  name: string\n  description: string\n  symbol: string\n  totalSupply: string\n  verified: boolean\n  createdAt: string\n  updatedAt: string\n  avatar: string\n  banner: {\n    large: string\n    small: string\n  }\n  attributes?: NftAttribute[] // returned for specific collection but not for all collections\n}\n\n// Get all collections\n// ${API_NFT}/collections/\nexport interface ApiCollectionsResponse {\n  total: number\n  data: ApiCollection[]\n}\n\n// Get single collection\n// ${API_NFT}/collections/${collectionAddress}\nexport interface ApiSingleCollectionResponse {\n  data: ApiCollection\n}\n\n// Get single collection\n// ${API_NFT}/collections/${collectionAddress}\nexport interface ApiTokenFilterResponse {\n  total: number\n  data: Record<string, ApiSingleTokenData>\n}\n\nexport interface ApiSingleTokenData {\n  name: string\n  description: string\n  image: Image\n  collection: {\n    name: string\n  }\n  attributes?: NftAttribute[]\n  tokenId?: string\n}\n\n// Get tokens within collection\n// ${API_NFT}/collections/${collectionAddress}/tokens\nexport interface ApiResponseCollectionTokens {\n  total: number\n  attributesDistribution: Record<string, number>\n  data: Record<string, ApiSingleTokenData>\n}\n\n// Get specific token data\n// ${API_NFT}/collections/${collectionAddress}/tokens/${tokenId}\nexport interface ApiResponseSpecificToken {\n  data: {\n    tokenId: string\n    name: string\n    description: string\n    image: Image\n    createdAt: string\n    updatedAt: string\n    attributes: NftAttribute[]\n    collection: {\n      name: string\n    }\n  }\n}\n\n// ${API_NFT}/collections/${collectionAddress}/distribution\nexport interface ApiCollectionDistribution {\n  total: number\n  data: Record<string, Record<string, number>>\n}\n\nexport interface ApiCollectionDistributionPB {\n  total: number\n  data: Record<string, number>\n}\n\nexport interface Activity {\n  marketEvent: MarketEvent\n  timestamp: string\n  tx: string\n  nft?: TokenMarketData\n  price?: string\n  otherParty?: string\n  buyer?: string\n  seller?: string\n}\n\nexport enum MarketEvent {\n  NEW = 'NEW',\n  CANCEL = 'CANCEL',\n  MODIFY = 'MODIFY',\n  BUY = 'BUY',\n  SELL = 'SELL',\n}\n\n/**\n * SUBGRAPH RESPONSES\n */\n\nexport interface CollectionMarketDataBaseFields {\n  id: string\n  name: string\n  symbol: string\n  active: boolean\n  totalTrades: string\n  totalVolumeBNB: string\n  numberTokensListed: string\n  creatorAddress: string\n  tradingFee: string\n  creatorFee: string\n  whitelistChecked: string\n}\n\nexport interface UserActivity {\n  askOrderHistory: AskOrder[]\n  buyTradeHistory: Transaction[]\n  sellTradeHistory: Transaction[]\n}\n","\"use strict\";\n(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[6737],{\n\n/***/ 27801:\n/***/ (function(__unused_webpack_module, __webpack_exports__) {\n\nvar DELIST_COLLECTIONS = {\n    \"0x4D89eBf7b1F66806A4C99Df71D22b7b9efC6bB0b\": {\n        active: false,\n        address: \"0x4D89eBf7b1F66806A4C99Df71D22b7b9efC6bB0b\",\n        avatar: \"\",\n        banner: {\n            large: \"\",\n            small: \"\"\n        },\n        createdAt: \"\",\n        creatorAddress: \"\",\n        creatorFee: \"\",\n        description: \"\",\n        id: \"0x4d89ebf7b1f66806a4c99df71d22b7b9efc6bb0b\",\n        name: \"Baked Potatoes\",\n        numberTokensListed: \"76\",\n        owner: \"0xCd1B0abBc3E55E91FCC5AEE393525e68478C2952\",\n        symbol: \"POT\",\n        totalSupply: \"\",\n        totalTrades: \"\",\n        totalVolumeBNB: \"\",\n        tradingFee: \"\",\n        updatedAt: \"\",\n        verified: true,\n        whitelistChecker: \"\"\n    },\n    \"0xC448498DDC536ad6F5d437325725dCf504d2d964\": {\n        active: false,\n        address: \"0xC448498DDC536ad6F5d437325725dCf504d2d964\",\n        avatar: \"\",\n        banner: {\n            large: \"\",\n            small: \"\"\n        },\n        createdAt: \"\",\n        creatorAddress: \"\",\n        creatorFee: \"\",\n        description: \"\",\n        id: \"0xC448498DDC536ad6F5d437325725dCf504d2d964\",\n        name: \"Catbread\",\n        numberTokensListed: \"9385\",\n        owner: \"0xC9A81c56eb07397989907fa6BcC121B593d8f141\",\n        symbol: \"CATBREADNFT\",\n        totalSupply: \"\",\n        totalTrades: \"\",\n        totalVolumeBNB: \"\",\n        tradingFee: \"\",\n        updatedAt: \"\",\n        verified: true,\n        whitelistChecker: \"\"\n    },\n    \"0x44d85770aEa263F9463418708125Cd95e308299B\": {\n        active: false,\n        address: \"0x44d85770aEa263F9463418708125Cd95e308299B\",\n        avatar: \"\",\n        banner: {\n            large: \"\",\n            small: \"\"\n        },\n        createdAt: \"\",\n        creatorAddress: \"\",\n        creatorFee: \"\",\n        description: \"\",\n        id: \"0x44d85770aEa263F9463418708125Cd95e308299B\",\n        name: \"BornBadBoys\",\n        numberTokensListed: \"1846\",\n        owner: \"0x952B8A6AC7957B769C6cAD934b128f2d27368565\",\n        symbol: \"BBB\",\n        totalSupply: \"\",\n        totalTrades: \"\",\n        totalVolumeBNB: \"\",\n        tradingFee: \"\",\n        updatedAt: \"\",\n        verified: true,\n        whitelistChecker: \"\"\n    }\n};\n/* harmony default export */ __webpack_exports__[\"Z\"] = (DELIST_COLLECTIONS);\n\n\n/***/ }),\n\n/***/ 46737:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"HD\": function() { return /* binding */ combineApiAndSgResponseToNftToken; },\n  \"nh\": function() { return /* binding */ fetchNftsFiltered; },\n  \"LU\": function() { return /* binding */ getAllPancakeBunniesLowestPrice; },\n  \"nP\": function() { return /* binding */ getAllPancakeBunniesRecentUpdatedAt; },\n  \"_N\": function() { return /* binding */ getCollection; },\n  \"Du\": function() { return /* binding */ getCollectionActivity; },\n  \"iE\": function() { return /* binding */ getCollectionDistributionApi; },\n  \"bG\": function() { return /* binding */ getCollections; },\n  \"A8\": function() { return /* binding */ getCompleteAccountNftData; },\n  \"dk\": function() { return /* binding */ getLatestListedNfts; },\n  \"Um\": function() { return /* binding */ getLeastMostPriceInCollection; },\n  \"Z1\": function() { return /* binding */ getMarketDataForTokenIds; },\n  \"M2\": function() { return /* binding */ getMetadataWithFallback; },\n  \"hb\": function() { return /* binding */ getNftApi; },\n  \"Rq\": function() { return /* binding */ getNftsFromCollectionApi; },\n  \"_C\": function() { return /* binding */ getNftsFromDifferentCollectionsApi; },\n  \"T5\": function() { return /* binding */ getNftsMarketData; },\n  \"DS\": function() { return /* binding */ getNftsOnChainMarketData; },\n  \"tU\": function() { return /* binding */ getNftsUpdatedMarketData; },\n  \"rD\": function() { return /* binding */ getPancakeBunniesAttributesField; },\n  \"AC\": function() { return /* binding */ getTokenActivity; },\n  \"_z\": function() { return /* binding */ getUserActivity; }\n});\n\n// UNUSED EXPORTS: attachMarketDataToWalletNfts, combineCollectionData, combineNftMarketAndMetadata, fetchWalletTokenIdsForCollections, getAccountNftsOnChainMarketData, getCollectionApi, getCollectionSg, getCollectionsApi, getCollectionsSg, getNftLocationForMarketNft, getNftsByBunnyIdSg, getNftsFromCollectionSg\n\n// EXTERNAL MODULE: ../../node_modules/@swc/helpers/src/_async_to_generator.mjs\nvar _async_to_generator = __webpack_require__(98788);\n// EXTERNAL MODULE: ../../node_modules/@swc/helpers/src/_object_spread.mjs\nvar _object_spread = __webpack_require__(70865);\n// EXTERNAL MODULE: ../../node_modules/@swc/helpers/src/_object_spread_props.mjs\nvar _object_spread_props = __webpack_require__(96670);\n// EXTERNAL MODULE: ../../node_modules/@swc/helpers/src/_sliced_to_array.mjs\nvar _sliced_to_array = __webpack_require__(87394);\n// EXTERNAL MODULE: ../../node_modules/@swc/helpers/src/_tagged_template_literal.mjs\nvar _tagged_template_literal = __webpack_require__(92228);\n// EXTERNAL MODULE: ../../node_modules/@swc/helpers/src/_to_consumable_array.mjs + 2 modules\nvar _to_consumable_array = __webpack_require__(50930);\n// EXTERNAL MODULE: ../../node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(5163);\n// EXTERNAL MODULE: ../../node_modules/graphql-request/dist/index.js\nvar dist = __webpack_require__(6647);\n// EXTERNAL MODULE: ../../node_modules/querystring/index.js\nvar querystring = __webpack_require__(56642);\n// EXTERNAL MODULE: ./src/config/constants/endpoints.ts\nvar endpoints = __webpack_require__(10494);\n// EXTERNAL MODULE: ./src/utils/multicall.ts\nvar multicall = __webpack_require__(25152);\n// EXTERNAL MODULE: ./src/utils/index.ts\nvar utils = __webpack_require__(5305);\n// EXTERNAL MODULE: ./src/config/abi/erc721.json\nvar erc721 = __webpack_require__(53400);\n// EXTERNAL MODULE: ../../node_modules/lodash/range.js\nvar range = __webpack_require__(2689);\nvar range_default = /*#__PURE__*/__webpack_require__.n(range);\n// EXTERNAL MODULE: ../../node_modules/lodash/groupBy.js\nvar groupBy = __webpack_require__(3440);\nvar groupBy_default = /*#__PURE__*/__webpack_require__.n(groupBy);\n// EXTERNAL MODULE: ./src/utils/contractHelpers.ts + 28 modules\nvar contractHelpers = __webpack_require__(80405);\n// EXTERNAL MODULE: ./src/config/constants/index.ts\nvar constants = __webpack_require__(74086);\n// EXTERNAL MODULE: ./src/config/constants/nftsCollections/delist.ts\nvar delist = __webpack_require__(27801);\n// EXTERNAL MODULE: ./src/views/Nft/market/constants.ts\nvar market_constants = __webpack_require__(36806);\n// EXTERNAL MODULE: ../../packages/utils/formatBalance.ts\nvar formatBalance = __webpack_require__(18426);\n// EXTERNAL MODULE: ./src/utils/addressHelpers.ts\nvar addressHelpers = __webpack_require__(70627);\n// EXTERNAL MODULE: ./src/config/abi/nftMarket.json\nvar nftMarket = __webpack_require__(60290);\n// EXTERNAL MODULE: ../../node_modules/lodash/fromPairs.js\nvar fromPairs = __webpack_require__(10017);\nvar fromPairs_default = /*#__PURE__*/__webpack_require__.n(fromPairs);\n// EXTERNAL MODULE: ../../node_modules/lodash/pickBy.js\nvar pickBy = __webpack_require__(42208);\nvar pickBy_default = /*#__PURE__*/__webpack_require__.n(pickBy);\n// EXTERNAL MODULE: ../../node_modules/lodash/size.js\nvar lodash_size = __webpack_require__(36402);\nvar size_default = /*#__PURE__*/__webpack_require__.n(lodash_size);\n// EXTERNAL MODULE: ./src/state/nftMarket/types.ts\nvar types = __webpack_require__(88587);\n;// CONCATENATED MODULE: ./src/state/nftMarket/queries.ts\nvar baseNftFields = \"\\n  tokenId\\n  metadataUrl\\n  currentAskPrice\\n  currentSeller\\n  latestTradedPriceInBNB\\n  tradeVolumeBNB\\n  totalTrades\\n  isTradable\\n  updatedAt\\n  otherId\\n  collection {\\n    id\\n  }\\n\";\nvar baseTransactionFields = \"\\n  id\\n  block\\n  timestamp\\n  askPrice\\n  netPrice\\n  withBNB\\n  buyer {\\n    id\\n  }\\n  seller {\\n    id\\n  }\\n\";\nvar collectionBaseFields = \"\\n  id\\n  name\\n  symbol\\n  active\\n  totalTrades\\n  totalVolumeBNB\\n  numberTokensListed\\n  creatorAddress\\n  tradingFee\\n  creatorFee\\n  whitelistChecker\\n\";\n\n;// CONCATENATED MODULE: ./src/state/nftMarket/helpers.ts\n\n\n\n\n\n\n\nfunction _templateObject() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getCollectionData($collectionAddress: String!) {\\n          collection(id: $collectionAddress) {\\n            \",\n        \"\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject = function _templateObject() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        {\\n          collections {\\n            \",\n        \"\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject1 = function _templateObject1() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getNftCollectionMarketData($collectionAddress: String!) {\\n          collection(id: $collectionAddress) {\\n            id\\n            nfts(orderBy:\",\n        \", skip: $skip, first: $first) {\\n             \",\n        \"\\n            }\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject2 = function _templateObject2() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject3() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getNftsByBunnyIdSg($collectionAddress: String!, $where: NFT_filter, $orderDirection: String!) {\\n          nfts(first: 30, where: $where, orderBy: currentAskPrice, orderDirection: $orderDirection) {\\n            \",\n        \"\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject3 = function _templateObject3() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject4() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getMarketDataForTokenIds($collectionAddress: String!, $where: NFT_filter) {\\n          collection(id: $collectionAddress) {\\n            id\\n            nfts(first: 1000, where: $where) {\\n              \",\n        \"\\n            }\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject4 = function _templateObject4() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject5() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getNftsMarketData($first: Int, $skip: Int!, $where: NFT_filter, $orderBy: NFT_orderBy, $orderDirection: OrderDirection) {\\n          nfts(where: $where, first: $first, orderBy: $orderBy, orderDirection: $orderDirection, skip: $skip) {\\n            \",\n        \"\\n            transactionHistory {\\n              \",\n        \"\\n            }\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject5 = function _templateObject5() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject6() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getAllPancakeBunniesLowestPrice {\\n          \",\n        \"\\n        }\\n      \"\n    ]);\n    _templateObject6 = function _templateObject6() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject7() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getAllPancakeBunniesLowestPrice {\\n          \",\n        \"\\n        }\\n      \"\n    ]);\n    _templateObject7 = function _templateObject7() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject8() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getUserActivity($address: String!) {\\n          user(id: $address) {\\n            buyTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\\n              \",\n        \"\\n              nft {\\n                \",\n        \"\\n              }\\n            }\\n            sellTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\\n              \",\n        \"\\n              nft {\\n                \",\n        \"\\n              }\\n            }\\n            askOrderHistory(first: 500, orderBy: timestamp, orderDirection: desc) {\\n              id\\n              block\\n              timestamp\\n              orderType\\n              askPrice\\n              nft {\\n                \",\n        \"\\n              }\\n            }\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject8 = function _templateObject8() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject9() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getCollectionActivity {\\n          \",\n        \"\\n          \",\n        \"\\n        }\\n      \"\n    ]);\n    _templateObject9 = function _templateObject9() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject10() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getCollectionActivity($tokenId: BigInt!, $address: ID!) {\\n          nfts(where:{tokenId: $tokenId, collection: $address}) {\\n            transactionHistory(orderBy: timestamp, orderDirection: desc) {\\n              \",\n        \"\\n                nft {\\n                  \",\n        \"\\n                }\\n            }\\n            askHistory(orderBy: timestamp, orderDirection: desc) {\\n                id\\n                block\\n                timestamp\\n                orderType\\n                askPrice\\n                seller {\\n                  id\\n                }\\n                nft {\\n                  \",\n        \"\\n                }\\n            }\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject10 = function _templateObject10() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject11() {\n    var data = (0,_tagged_template_literal/* default */.Z)([\n        \"\\n        query getLatestNftMarketData($first: Int) {\\n          nfts(where: { isTradable: true }, orderBy: updatedAt , orderDirection: desc, first: $first) {\\n            \",\n        \"\\n            collection {\\n              id\\n            }\\n          }\\n        }\\n      \"\n    ]);\n    _templateObject11 = function _templateObject11() {\n        return data;\n    };\n    return data;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * API HELPERS\n */ /**\n * Fetch static data from all collections using the API\n * @returns\n */ var getCollectionsApi = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function() {\n        var res, json;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        fetch(\"\".concat(endpoints/* API_NFT */.C1, \"/collections\"))\n                    ];\n                case 1:\n                    res = _state.sent();\n                    if (!res.ok) return [\n                        3,\n                        3\n                    ];\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 2:\n                    json = _state.sent();\n                    return [\n                        2,\n                        json\n                    ];\n                case 3:\n                    console.error(\"Failed to fetch NFT collections\", res.statusText);\n                    return [\n                        2,\n                        null\n                    ];\n            }\n        });\n    });\n    return function getCollectionsApi() {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar fetchCollectionsTotalSupply = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collections) {\n        var totalSupplyCalls, totalSupplyRaw, totalSupply;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    totalSupplyCalls = collections.filter(function(collection) {\n                        return collection === null || collection === void 0 ? void 0 : collection.address;\n                    }).map(function(collection) {\n                        return {\n                            address: collection.address.toLowerCase(),\n                            name: \"totalSupply\"\n                        };\n                    });\n                    if (!(totalSupplyCalls.length > 0)) return [\n                        3,\n                        2\n                    ];\n                    return [\n                        4,\n                        (0,multicall/* multicallv2 */.v)({\n                            abi: erc721,\n                            calls: totalSupplyCalls,\n                            options: {\n                                requireSuccess: false\n                            }\n                        })\n                    ];\n                case 1:\n                    totalSupplyRaw = _state.sent();\n                    totalSupply = totalSupplyRaw.flat();\n                    return [\n                        2,\n                        totalSupply.map(function(totalCount) {\n                            return totalCount ? totalCount.toNumber() : 0;\n                        })\n                    ];\n                case 2:\n                    return [\n                        2,\n                        []\n                    ];\n            }\n        });\n    });\n    return function fetchCollectionsTotalSupply(collections) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch all collections data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */ var getCollections = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function() {\n        var ref, collections, collectionsMarket, ref1, collectionApiData, collectionsTotalSupply, collectionApiDataCombinedOnChain, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        3,\n                        ,\n                        4\n                    ]);\n                    return [\n                        4,\n                        Promise.all([\n                            getCollectionsApi(),\n                            getCollectionsSg()\n                        ])\n                    ];\n                case 1:\n                    ref = _sliced_to_array/* default.apply */.Z.apply(void 0, [\n                        _state.sent(),\n                        2\n                    ]), collections = ref[0], collectionsMarket = ref[1];\n                    collectionApiData = (ref1 = collections === null || collections === void 0 ? void 0 : collections.data) !== null && ref1 !== void 0 ? ref1 : [];\n                    return [\n                        4,\n                        fetchCollectionsTotalSupply(collectionApiData)\n                    ];\n                case 2:\n                    collectionsTotalSupply = _state.sent();\n                    collectionApiDataCombinedOnChain = collectionApiData.map(function(collection, index) {\n                        var totalSupplyFromApi = Number(collection === null || collection === void 0 ? void 0 : collection.totalSupply) || 0;\n                        var totalSupplyFromOnChain = collectionsTotalSupply[index];\n                        return (0,_object_spread_props/* default */.Z)((0,_object_spread/* default */.Z)({}, collection), {\n                            totalSupply: Math.max(totalSupplyFromApi, totalSupplyFromOnChain).toString()\n                        });\n                    });\n                    return [\n                        2,\n                        combineCollectionData(collectionApiDataCombinedOnChain, collectionsMarket)\n                    ];\n                case 3:\n                    error = _state.sent();\n                    console.error(\"Unable to fetch data:\", error);\n                    return [\n                        2,\n                        null\n                    ];\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getCollections() {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch collection data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */ var getCollection = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress) {\n        var ref, collection, collectionMarket, collectionsTotalSupply, totalSupplyFromApi, totalSupplyFromOnChain, collectionApiDataCombinedOnChain, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        3,\n                        ,\n                        4\n                    ]);\n                    return [\n                        4,\n                        Promise.all([\n                            getCollectionApi(collectionAddress),\n                            getCollectionSg(collectionAddress)\n                        ])\n                    ];\n                case 1:\n                    ref = _sliced_to_array/* default.apply */.Z.apply(void 0, [\n                        _state.sent(),\n                        2\n                    ]), collection = ref[0], collectionMarket = ref[1];\n                    return [\n                        4,\n                        fetchCollectionsTotalSupply([\n                            collection\n                        ])\n                    ];\n                case 2:\n                    collectionsTotalSupply = _state.sent();\n                    totalSupplyFromApi = Number(collection === null || collection === void 0 ? void 0 : collection.totalSupply) || 0;\n                    totalSupplyFromOnChain = collectionsTotalSupply[0];\n                    collectionApiDataCombinedOnChain = (0,_object_spread_props/* default */.Z)((0,_object_spread/* default */.Z)({}, collection), {\n                        totalSupply: Math.max(totalSupplyFromApi, totalSupplyFromOnChain).toString()\n                    });\n                    return [\n                        2,\n                        combineCollectionData([\n                            collectionApiDataCombinedOnChain\n                        ], [\n                            collectionMarket\n                        ])\n                    ];\n                case 3:\n                    error = _state.sent();\n                    console.error(\"Unable to fetch data:\", error);\n                    return [\n                        2,\n                        null\n                    ];\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getCollection(collectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch static data from a collection using the API\n * @returns\n */ var getCollectionApi = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress) {\n        var res, json;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        fetch(\"\".concat(endpoints/* API_NFT */.C1, \"/collections/\").concat(collectionAddress))\n                    ];\n                case 1:\n                    res = _state.sent();\n                    if (!res.ok) return [\n                        3,\n                        3\n                    ];\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 2:\n                    json = _state.sent();\n                    return [\n                        2,\n                        json.data\n                    ];\n                case 3:\n                    console.error(\"API: Failed to fetch NFT collection \".concat(collectionAddress), res.statusText);\n                    return [\n                        2,\n                        null\n                    ];\n            }\n        });\n    });\n    return function getCollectionApi(collectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch static data for all nfts in a collection using the API\n * @param collectionAddress\n * @param size\n * @param page\n * @returns\n */ var getNftsFromCollectionApi = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress) {\n        var size, page, isPBCollection, requestPath, res, data, filteredAttributesDistribution, filteredData, filteredTotal, error;\n        var _arguments = arguments;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    size = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : 100, page = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : 1;\n                    isPBCollection = (0,utils/* isAddress */.UJ)(collectionAddress) === market_constants/* pancakeBunniesAddress */.J;\n                    requestPath = \"\".concat(endpoints/* API_NFT */.C1, \"/collections/\").concat(collectionAddress, \"/tokens\").concat(!isPBCollection ? \"?page=\".concat(page, \"&size=\").concat(size) : \"\");\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        5,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        fetch(requestPath)\n                    ];\n                case 2:\n                    res = _state.sent();\n                    if (!res.ok) return [\n                        3,\n                        4\n                    ];\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 3:\n                    data = _state.sent();\n                    filteredAttributesDistribution = pickBy_default()(data.attributesDistribution, Boolean);\n                    filteredData = pickBy_default()(data.data, Boolean);\n                    filteredTotal = size_default()(filteredData);\n                    return [\n                        2,\n                        (0,_object_spread_props/* default */.Z)((0,_object_spread/* default */.Z)({}, data), {\n                            total: filteredTotal,\n                            attributesDistribution: filteredAttributesDistribution,\n                            data: filteredData\n                        })\n                    ];\n                case 4:\n                    console.error(\"API: Failed to fetch NFT tokens for \".concat(collectionAddress, \" collection\"), res.statusText);\n                    return [\n                        2,\n                        null\n                    ];\n                case 5:\n                    error = _state.sent();\n                    console.error(\"API: Failed to fetch NFT tokens for \".concat(collectionAddress, \" collection\"), error);\n                    return [\n                        2,\n                        null\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getNftsFromCollectionApi(collectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch a single NFT using the API\n * @param collectionAddress\n * @param tokenId\n * @returns NFT from API\n */ var getNftApi = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress, tokenId) {\n        var res, json;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        fetch(\"\".concat(endpoints/* API_NFT */.C1, \"/collections/\").concat(collectionAddress, \"/tokens/\").concat(tokenId))\n                    ];\n                case 1:\n                    res = _state.sent();\n                    if (!res.ok) return [\n                        3,\n                        3\n                    ];\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 2:\n                    json = _state.sent();\n                    return [\n                        2,\n                        json.data\n                    ];\n                case 3:\n                    console.error(\"API: Can't fetch NFT token \".concat(tokenId, \" in \").concat(collectionAddress), res.status);\n                    return [\n                        2,\n                        null\n                    ];\n            }\n        });\n    });\n    return function getNftApi(collectionAddress, tokenId) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch a list of NFT from different collections\n * @param from Array of { collectionAddress: string; tokenId: string }\n * @returns Array of NFT from API\n */ var getNftsFromDifferentCollectionsApi = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(from) {\n        var promises, responses;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    promises = from.map(function(nft) {\n                        return getNftApi(nft.collectionAddress, nft.tokenId);\n                    });\n                    return [\n                        4,\n                        Promise.all(promises)\n                    ];\n                case 1:\n                    responses = _state.sent();\n                    // Sometimes API can't find some tokens (e.g. 404 response)\n                    // at least return the ones that returned successfully\n                    return [\n                        2,\n                        responses.filter(function(resp) {\n                            return resp;\n                        }).map(function(res, index) {\n                            return {\n                                tokenId: res.tokenId,\n                                name: res.name,\n                                collectionName: res.collection.name,\n                                collectionAddress: from[index].collectionAddress,\n                                description: res.description,\n                                attributes: res.attributes,\n                                createdAt: res.createdAt,\n                                updatedAt: res.updatedAt,\n                                image: res.image\n                            };\n                        })\n                    ];\n            }\n        });\n    });\n    return function getNftsFromDifferentCollectionsApi(from) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * SUBGRAPH HELPERS\n */ /**\n * Fetch market data from a collection using the Subgraph\n * @returns\n */ var getCollectionSg = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress) {\n        var res, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject(), collectionBaseFields), {\n                            collectionAddress: collectionAddress.toLowerCase()\n                        })\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res.collection\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch collection\", error);\n                    return [\n                        2,\n                        null\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getCollectionSg(collectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch market data from all collections using the Subgraph\n * @returns\n */ var getCollectionsSg = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function() {\n        var res, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject1(), collectionBaseFields))\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res.collections\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch NFT collections\", error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getCollectionsSg() {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch market data for nfts in a collection using the Subgraph\n * @param collectionAddress\n * @param first\n * @param skip\n * @returns\n */ var getNftsFromCollectionSg = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress) {\n        var first, skip, isPBCollection, res, error;\n        var _arguments = arguments;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    first = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : 1000, skip = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : 0;\n                    isPBCollection = (0,utils/* isAddress */.UJ)(collectionAddress) === market_constants/* pancakeBunniesAddress */.J;\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        3,\n                        ,\n                        4\n                    ]);\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject2(), isPBCollection ? \"updatedAt\" : \"tokenId\", baseNftFields), {\n                            collectionAddress: collectionAddress.toLowerCase(),\n                            skip: skip,\n                            first: first\n                        })\n                    ];\n                case 2:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res.collection.nfts\n                    ];\n                case 3:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch NFTs from collection\", error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getNftsFromCollectionSg(collectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */ var getNftsByBunnyIdSg = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(bunnyId, existingTokenIds, orderDirection) {\n        var where, res, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    where = existingTokenIds.length > 0 ? {\n                        otherId: bunnyId,\n                        isTradable: true,\n                        tokenId_not_in: existingTokenIds\n                    } : {\n                        otherId: bunnyId,\n                        isTradable: true\n                    };\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject3(), baseNftFields), {\n                            collectionAddress: market_constants/* pancakeBunniesAddress.toLowerCase */.J.toLowerCase(),\n                            where: where,\n                            orderDirection: orderDirection\n                        })\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res.nfts\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch collection NFTs for bunny id \".concat(bunnyId), error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getNftsByBunnyIdSg(bunnyId, existingTokenIds, orderDirection) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */ var getMarketDataForTokenIds = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress, existingTokenIds) {\n        var res, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    if (existingTokenIds.length === 0) {\n                        return [\n                            2,\n                            []\n                        ];\n                    }\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject4(), baseNftFields), {\n                            collectionAddress: collectionAddress.toLowerCase(),\n                            where: {\n                                tokenId_in: existingTokenIds\n                            }\n                        })\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res.collection.nfts\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch market data for NFTs stored tokens\", error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getMarketDataForTokenIds(collectionAddress, existingTokenIds) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getNftsOnChainMarketData = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress, tokenIds) {\n        var nftMarketContract, response, askInfo, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    nftMarketContract = (0,contractHelpers/* getNftMarketContract */.X$)();\n                    return [\n                        4,\n                        nftMarketContract.viewAsksByCollectionAndTokenIds(collectionAddress.toLowerCase(), tokenIds)\n                    ];\n                case 1:\n                    response = _state.sent();\n                    askInfo = response === null || response === void 0 ? void 0 : response.askInfo;\n                    if (!askInfo) return [\n                        2,\n                        []\n                    ];\n                    return [\n                        2,\n                        askInfo.map(function(tokenAskInfo, index) {\n                            if (!tokenAskInfo.seller || !tokenAskInfo.price) return null;\n                            var currentSeller = tokenAskInfo.seller;\n                            var isTradable = currentSeller.toLowerCase() !== constants/* NOT_ON_SALE_SELLER */.Vc;\n                            var currentAskPrice = tokenAskInfo.price && (0,formatBalance/* formatBigNumber */.dp)(tokenAskInfo.price);\n                            return {\n                                collection: {\n                                    id: collectionAddress.toLowerCase()\n                                },\n                                tokenId: tokenIds[index],\n                                currentSeller: currentSeller,\n                                isTradable: isTradable,\n                                currentAskPrice: currentAskPrice\n                            };\n                        }).filter(Boolean)\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch NFTs onchain market data\", error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getNftsOnChainMarketData(collectionAddress, tokenIds) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getNftsUpdatedMarketData = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress, tokenIds) {\n        var nftMarketContract, response, askInfo, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    nftMarketContract = (0,contractHelpers/* getNftMarketContract */.X$)();\n                    return [\n                        4,\n                        nftMarketContract.viewAsksByCollectionAndTokenIds(collectionAddress.toLowerCase(), tokenIds)\n                    ];\n                case 1:\n                    response = _state.sent();\n                    askInfo = response === null || response === void 0 ? void 0 : response.askInfo;\n                    if (!askInfo) return [\n                        2,\n                        null\n                    ];\n                    return [\n                        2,\n                        askInfo.map(function(tokenAskInfo, index) {\n                            var isTradable = tokenAskInfo.seller ? tokenAskInfo.seller.toLowerCase() !== constants/* NOT_ON_SALE_SELLER */.Vc : false;\n                            return {\n                                tokenId: tokenIds[index],\n                                currentSeller: tokenAskInfo.seller,\n                                isTradable: isTradable,\n                                currentAskPrice: tokenAskInfo.price\n                            };\n                        })\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch updated NFT market data\", error);\n                    return [\n                        2,\n                        null\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getNftsUpdatedMarketData(collectionAddress, tokenIds) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getAccountNftsOnChainMarketData = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collections, account) {\n        var nftMarketAddress, collectionList, askCalls, askCallsResultsRaw, askCallsResults, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    nftMarketAddress = (0,addressHelpers/* getNftMarketAddress */.D4)();\n                    collectionList = Object.values(collections);\n                    askCalls = collectionList.map(function(collection) {\n                        var collectionAddress = collection.address;\n                        return {\n                            address: nftMarketAddress,\n                            name: \"viewAsksByCollectionAndSeller\",\n                            params: [\n                                collectionAddress,\n                                account,\n                                0,\n                                1000\n                            ]\n                        };\n                    });\n                    return [\n                        4,\n                        (0,multicall/* multicallv2 */.v)({\n                            abi: nftMarket,\n                            calls: askCalls,\n                            options: {\n                                requireSuccess: false\n                            }\n                        })\n                    ];\n                case 1:\n                    askCallsResultsRaw = _state.sent();\n                    askCallsResults = askCallsResultsRaw.map(function(askCallsResultRaw, askCallIndex) {\n                        var ref;\n                        if (!(askCallsResultRaw === null || askCallsResultRaw === void 0 ? void 0 : askCallsResultRaw.tokenIds) || !(askCallsResultRaw === null || askCallsResultRaw === void 0 ? void 0 : askCallsResultRaw.askInfo) || !((ref = collectionList[askCallIndex]) === null || ref === void 0 ? void 0 : ref.address)) return null;\n                        return askCallsResultRaw.tokenIds.map(function(tokenId, tokenIdIndex) {\n                            if (!tokenId || !askCallsResultRaw.askInfo[tokenIdIndex] || !askCallsResultRaw.askInfo[tokenIdIndex].price) return null;\n                            var currentAskPrice = (0,formatBalance/* formatBigNumber */.dp)(askCallsResultRaw.askInfo[tokenIdIndex].price);\n                            return {\n                                collection: {\n                                    id: collectionList[askCallIndex].address.toLowerCase()\n                                },\n                                tokenId: tokenId.toString(),\n                                account: account,\n                                isTradable: true,\n                                currentAskPrice: currentAskPrice\n                            };\n                        }).filter(Boolean);\n                    }).flat().filter(Boolean);\n                    return [\n                        2,\n                        askCallsResults\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch NFTs onchain market data\", error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getAccountNftsOnChainMarketData(collections, account) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getNftsMarketData = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function() {\n        var where, first, orderBy, orderDirection, skip, res, error;\n        var _arguments = arguments;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    where = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : {}, first = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : 1000, orderBy = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : \"id\", orderDirection = _arguments.length > 3 && _arguments[3] !== void 0 ? _arguments[3] : \"desc\", skip = _arguments.length > 4 && _arguments[4] !== void 0 ? _arguments[4] : 0;\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        3,\n                        ,\n                        4\n                    ]);\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject5(), baseNftFields, baseTransactionFields), {\n                            where: where,\n                            first: first,\n                            skip: skip,\n                            orderBy: orderBy,\n                            orderDirection: orderDirection\n                        })\n                    ];\n                case 2:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res.nfts\n                    ];\n                case 3:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch NFTs market data\", error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getNftsMarketData() {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getAllPancakeBunniesLowestPrice = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(bunnyIds) {\n        var singlePancakeBunnySubQueries, rawResponse, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    singlePancakeBunnySubQueries = bunnyIds.map(function(bunnyId) {\n                        return \"b\".concat(bunnyId, \":nfts(first: 1, where: { otherId: \").concat(bunnyId, \", isTradable: true }, orderBy: currentAskPrice, orderDirection: asc) {\\n        currentAskPrice\\n      }\\n    \");\n                    });\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject6(), singlePancakeBunnySubQueries))\n                    ];\n                case 1:\n                    rawResponse = _state.sent();\n                    return [\n                        2,\n                        fromPairs_default()(Object.keys(rawResponse).map(function(subQueryKey) {\n                            var bunnyId = subQueryKey.split(\"b\")[1];\n                            return [\n                                bunnyId,\n                                rawResponse[subQueryKey].length > 0 ? parseFloat(rawResponse[subQueryKey][0].currentAskPrice) : Infinity, \n                            ];\n                        }))\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch PancakeBunnies lowest prices\", error);\n                    return [\n                        2,\n                        {}\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getAllPancakeBunniesLowestPrice(bunnyIds) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getAllPancakeBunniesRecentUpdatedAt = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(bunnyIds) {\n        var singlePancakeBunnySubQueries, rawResponse, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    singlePancakeBunnySubQueries = bunnyIds.map(function(bunnyId) {\n                        return \"b\".concat(bunnyId, \":nfts(first: 1, where: { otherId: \").concat(bunnyId, \", isTradable: true }, orderBy: updatedAt, orderDirection: desc) {\\n        updatedAt\\n      }\\n    \");\n                    });\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject7(), singlePancakeBunnySubQueries))\n                    ];\n                case 1:\n                    rawResponse = _state.sent();\n                    return [\n                        2,\n                        fromPairs_default()(Object.keys(rawResponse).map(function(subQueryKey) {\n                            var bunnyId = subQueryKey.split(\"b\")[1];\n                            return [\n                                bunnyId,\n                                rawResponse[subQueryKey].length > 0 ? Number(rawResponse[subQueryKey][0].updatedAt) : -Infinity, \n                            ];\n                        }))\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch PancakeBunnies latest market updates\", error);\n                    return [\n                        2,\n                        {}\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getAllPancakeBunniesRecentUpdatedAt(bunnyIds) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Returns the lowest/highest price of any NFT in a collection\n */ var getLeastMostPriceInCollection = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress) {\n        var orderDirection, response, _response, nftSg, error;\n        var _arguments = arguments;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    orderDirection = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : \"asc\";\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        3,\n                        ,\n                        4\n                    ]);\n                    return [\n                        4,\n                        getNftsMarketData({\n                            collection: collectionAddress.toLowerCase(),\n                            isTradable: true\n                        }, 1, \"currentAskPrice\", orderDirection)\n                    ];\n                case 2:\n                    response = _state.sent();\n                    if (response.length === 0) {\n                        return [\n                            2,\n                            0\n                        ];\n                    }\n                    _response = (0,_sliced_to_array/* default */.Z)(response, 1), nftSg = _response[0];\n                    return [\n                        2,\n                        parseFloat(nftSg.currentAskPrice)\n                    ];\n                case 3:\n                    error = _state.sent();\n                    console.error(\"Failed to lowest price NFTs in collection \".concat(collectionAddress), error);\n                    return [\n                        2,\n                        0\n                    ];\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getLeastMostPriceInCollection(collectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch user trading data for buyTradeHistory, sellTradeHistory and askOrderHistory from the Subgraph\n * @param where a User_filter where condition\n * @returns a UserActivity object\n */ var getUserActivity = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(address) {\n        var res, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject8(), baseTransactionFields, baseNftFields, baseTransactionFields, baseNftFields, baseNftFields), {\n                            address: address\n                        })\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res.user || {\n                            askOrderHistory: [],\n                            buyTradeHistory: [],\n                            sellTradeHistory: []\n                        }\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch user Activity\", error);\n                    return [\n                        2,\n                        {\n                            askOrderHistory: [],\n                            buyTradeHistory: [],\n                            sellTradeHistory: []\n                        }\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getUserActivity(address) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getCollectionActivity = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(address, nftActivityFilter, itemPerQuery) {\n        var getAskOrderEvent, isFetchAllCollections, hasCollectionFilter, collectionFilterGql, askOrderTypeFilter, askOrderIncluded, askOrderTypeFilterGql, transactionIncluded, askOrderQueryItem, transactionQueryItem, askOrderGql, transactionGql, res, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    getAskOrderEvent = function(orderType) {\n                        switch(orderType){\n                            case types/* MarketEvent.CANCEL */.YG.CANCEL:\n                                return types/* AskOrderType.CANCEL */.cP.CANCEL;\n                            case types/* MarketEvent.MODIFY */.YG.MODIFY:\n                                return types/* AskOrderType.MODIFY */.cP.MODIFY;\n                            case types/* MarketEvent.NEW */.YG.NEW:\n                                return types/* AskOrderType.NEW */.cP.NEW;\n                            default:\n                                return types/* AskOrderType.MODIFY */.cP.MODIFY;\n                        }\n                    };\n                    isFetchAllCollections = address === \"\";\n                    hasCollectionFilter = nftActivityFilter.collectionFilters.length > 0;\n                    collectionFilterGql = !isFetchAllCollections ? \"collection: \".concat(JSON.stringify(address)) : hasCollectionFilter ? \"collection_in: \".concat(JSON.stringify(nftActivityFilter.collectionFilters)) : \"\";\n                    askOrderTypeFilter = nftActivityFilter.typeFilters.filter(function(marketEvent) {\n                        return marketEvent !== types/* MarketEvent.SELL */.YG.SELL;\n                    }).map(function(marketEvent) {\n                        return getAskOrderEvent(marketEvent);\n                    });\n                    askOrderIncluded = nftActivityFilter.typeFilters.length === 0 || askOrderTypeFilter.length > 0;\n                    askOrderTypeFilterGql = askOrderTypeFilter.length > 0 ? \"orderType_in: \".concat(JSON.stringify(askOrderTypeFilter)) : \"\";\n                    transactionIncluded = nftActivityFilter.typeFilters.length === 0 || nftActivityFilter.typeFilters.some(function(marketEvent) {\n                        return marketEvent === types/* MarketEvent.BUY */.YG.BUY || marketEvent === types/* MarketEvent.SELL */.YG.SELL;\n                    });\n                    askOrderQueryItem = itemPerQuery / 2;\n                    transactionQueryItem = itemPerQuery / 2;\n                    if (!askOrderIncluded || !transactionIncluded) {\n                        askOrderQueryItem = !askOrderIncluded ? 0 : itemPerQuery;\n                        transactionQueryItem = !transactionIncluded ? 0 : itemPerQuery;\n                    }\n                    askOrderGql = askOrderIncluded ? \"askOrders(first: \".concat(askOrderQueryItem, \", orderBy: timestamp, orderDirection: desc, where:{\\n            \").concat(collectionFilterGql, \", \").concat(askOrderTypeFilterGql, \"\\n          }) {\\n              id\\n              block\\n              timestamp\\n              orderType\\n              askPrice\\n              seller {\\n                id\\n              }\\n              nft {\\n                \").concat(baseNftFields, \"\\n              }\\n          }\") : \"\";\n                    transactionGql = transactionIncluded ? \"transactions(first: \".concat(transactionQueryItem, \", orderBy: timestamp, orderDirection: desc, where:{\\n            \").concat(collectionFilterGql, \"\\n          }) {\\n            \").concat(baseTransactionFields, \"\\n              nft {\\n                \").concat(baseNftFields, \"\\n              }\\n          }\") : \"\";\n                    _state.label = 1;\n                case 1:\n                    _state.trys.push([\n                        1,\n                        3,\n                        ,\n                        4\n                    ]);\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject9(), askOrderGql, transactionGql))\n                    ];\n                case 2:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res || {\n                            askOrders: [],\n                            transactions: []\n                        }\n                    ];\n                case 3:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch collection Activity\", error);\n                    return [\n                        2,\n                        {\n                            askOrders: [],\n                            transactions: []\n                        }\n                    ];\n                case 4:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getCollectionActivity(address, nftActivityFilter, itemPerQuery) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar getTokenActivity = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(tokenId, collectionAddress) {\n        var res, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject10(), baseTransactionFields, baseNftFields, baseNftFields), {\n                            tokenId: tokenId,\n                            address: collectionAddress\n                        })\n                    ];\n                case 1:\n                    res = _state.sent();\n                    if (res.nfts.length > 0) {\n                        return [\n                            2,\n                            {\n                                askOrders: res.nfts[0].askHistory,\n                                transactions: res.nfts[0].transactionHistory\n                            }\n                        ];\n                    }\n                    return [\n                        2,\n                        {\n                            askOrders: [],\n                            transactions: []\n                        }\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch token Activity\", error);\n                    return [\n                        2,\n                        {\n                            askOrders: [],\n                            transactions: []\n                        }\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getTokenActivity(tokenId, collectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Get the most recently listed NFTs\n * @param first Number of nfts to retrieve\n * @returns NftTokenSg[]\n */ var getLatestListedNfts = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(first) {\n        var res, error;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _state.trys.push([\n                        0,\n                        2,\n                        ,\n                        3\n                    ]);\n                    return [\n                        4,\n                        (0,dist.request)(endpoints/* GRAPH_API_NFTMARKET */.Bd, (0,dist.gql)(_templateObject11(), baseNftFields), {\n                            first: first\n                        })\n                    ];\n                case 1:\n                    res = _state.sent();\n                    return [\n                        2,\n                        res.nfts\n                    ];\n                case 2:\n                    error = _state.sent();\n                    console.error(\"Failed to fetch NFTs market data\", error);\n                    return [\n                        2,\n                        []\n                    ];\n                case 3:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return function getLatestListedNfts(first) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Filter NFTs from a collection\n * @param collectionAddress\n * @returns\n */ var fetchNftsFiltered = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress, filters) {\n        var res, data;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        fetch(\"\".concat(endpoints/* API_NFT */.C1, \"/collections/\").concat(collectionAddress, \"/filter?\").concat((0,querystring.stringify)(filters)))\n                    ];\n                case 1:\n                    res = _state.sent();\n                    if (!res.ok) return [\n                        3,\n                        3\n                    ];\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 2:\n                    data = _state.sent();\n                    return [\n                        2,\n                        data\n                    ];\n                case 3:\n                    console.error(\"API: Failed to fetch NFT collection \".concat(collectionAddress), res.statusText);\n                    return [\n                        2,\n                        null\n                    ];\n            }\n        });\n    });\n    return function fetchNftsFiltered(collectionAddress, filters) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * OTHER HELPERS\n */ var getMetadataWithFallback = function(apiMetadata, bunnyId) {\n    var _bunnyId;\n    // The fallback is just for the testnet where some bunnies don't exist\n    return (_bunnyId = apiMetadata[bunnyId]) !== null && _bunnyId !== void 0 ? _bunnyId : {\n        name: \"\",\n        description: \"\",\n        collection: {\n            name: \"Pancake Bunnies\"\n        },\n        image: {\n            original: \"\",\n            thumbnail: \"\"\n        }\n    };\n};\nvar getPancakeBunniesAttributesField = function(bunnyId) {\n    // Generating attributes field that is not returned by API\n    // but can be \"faked\" since objects are keyed with bunny id\n    return [\n        {\n            traitType: \"bunnyId\",\n            value: bunnyId,\n            displayType: null\n        }, \n    ];\n};\nvar combineApiAndSgResponseToNftToken = function(apiMetadata, marketData, attributes) {\n    return {\n        tokenId: marketData.tokenId,\n        name: apiMetadata.name,\n        description: apiMetadata.description,\n        collectionName: apiMetadata.collection.name,\n        collectionAddress: market_constants/* pancakeBunniesAddress */.J,\n        image: apiMetadata.image,\n        marketData: marketData,\n        attributes: attributes\n    };\n};\nvar fetchWalletTokenIdsForCollections = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(account, collections) {\n        var balanceOfCalls, balanceOfCallsResultRaw, balanceOfCallsResult, tokenIdCalls, tokenIdResultRaw, tokenIdResult, nftLocation, walletNfts;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    balanceOfCalls = Object.values(collections).map(function(collection) {\n                        var collectionAddress = collection.address;\n                        return {\n                            address: collectionAddress,\n                            name: \"balanceOf\",\n                            params: [\n                                account\n                            ]\n                        };\n                    });\n                    return [\n                        4,\n                        (0,multicall/* multicallv2 */.v)({\n                            abi: erc721,\n                            calls: balanceOfCalls,\n                            options: {\n                                requireSuccess: false\n                            }\n                        })\n                    ];\n                case 1:\n                    balanceOfCallsResultRaw = _state.sent();\n                    balanceOfCallsResult = balanceOfCallsResultRaw.flat();\n                    tokenIdCalls = Object.values(collections).map(function(collection, index) {\n                        var ref;\n                        var ref1;\n                        var balanceOf = (ref1 = (ref = balanceOfCallsResult[index]) === null || ref === void 0 ? void 0 : ref.toNumber()) !== null && ref1 !== void 0 ? ref1 : 0;\n                        var collectionAddress = collection.address;\n                        return range_default()(balanceOf).map(function(tokenIndex) {\n                            return {\n                                address: collectionAddress,\n                                name: \"tokenOfOwnerByIndex\",\n                                params: [\n                                    account,\n                                    tokenIndex\n                                ]\n                            };\n                        });\n                    }).flat();\n                    return [\n                        4,\n                        (0,multicall/* multicallv2 */.v)({\n                            abi: erc721,\n                            calls: tokenIdCalls,\n                            options: {\n                                requireSuccess: false\n                            }\n                        })\n                    ];\n                case 2:\n                    tokenIdResultRaw = _state.sent();\n                    tokenIdResult = tokenIdResultRaw.flat();\n                    nftLocation = types/* NftLocation.WALLET */.Fb.WALLET;\n                    walletNfts = tokenIdResult.reduce(function(acc, tokenIdBn, index) {\n                        if (tokenIdBn) {\n                            var _index = tokenIdCalls[index], collectionAddress = _index.address;\n                            acc.push({\n                                tokenId: tokenIdBn.toString(),\n                                collectionAddress: collectionAddress,\n                                nftLocation: nftLocation\n                            });\n                        }\n                        return acc;\n                    }, []);\n                    return [\n                        2,\n                        walletNfts\n                    ];\n            }\n        });\n    });\n    return function fetchWalletTokenIdsForCollections(account, collections) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Helper to combine data from the collections' API and subgraph\n */ var combineCollectionData = function(collectionApiData, collectionSgData) {\n    var collectionsMarketObj = fromPairs_default()(collectionSgData.map(function(current) {\n        return [\n            current.id,\n            current\n        ];\n    }));\n    return fromPairs_default()(collectionApiData.filter(function(collection) {\n        return collection === null || collection === void 0 ? void 0 : collection.address;\n    }).map(function(current) {\n        var collectionMarket = collectionsMarketObj[current.address.toLowerCase()];\n        var collection = (0,_object_spread/* default */.Z)({}, current, collectionMarket);\n        if (current.name) {\n            collection.name = current.name;\n        }\n        return [\n            current.address,\n            collection\n        ];\n    }));\n};\n/**\n * Evaluate whether a market NFT is in a users wallet, their profile picture, or on sale\n * @param tokenId string\n * @param tokenIdsInWallet array of tokenIds in wallet\n * @param tokenIdsForSale array of tokenIds on sale\n * @param profileNftId Optional tokenId of users' profile picture\n * @returns NftLocation enum value\n */ var getNftLocationForMarketNft = function(tokenId, tokenIdsInWallet, tokenIdsForSale, profileNftId) {\n    if (tokenId === profileNftId) {\n        return types/* NftLocation.PROFILE */.Fb.PROFILE;\n    }\n    if (tokenIdsForSale.includes(tokenId)) {\n        return types/* NftLocation.FORSALE */.Fb.FORSALE;\n    }\n    if (tokenIdsInWallet.includes(tokenId)) {\n        return types/* NftLocation.WALLET */.Fb.WALLET;\n    }\n    console.error(\"Cannot determine location for tokenID \".concat(tokenId, \", defaulting to NftLocation.WALLET\"));\n    return types/* NftLocation.WALLET */.Fb.WALLET;\n};\n/**\n * Construct complete TokenMarketData entities with a users' wallet NFT ids and market data for their wallet NFTs\n * @param walletNfts TokenIdWithCollectionAddress\n * @param marketDataForWalletNfts TokenMarketData[]\n * @returns TokenMarketData[]\n */ var attachMarketDataToWalletNfts = function(walletNfts, marketDataForWalletNfts) {\n    var walletNftsWithMarketData = walletNfts.map(function(walletNft) {\n        var marketData = marketDataForWalletNfts.find(function(marketNft) {\n            return marketNft.tokenId === walletNft.tokenId && marketNft.collection.id.toLowerCase() === walletNft.collectionAddress.toLowerCase();\n        });\n        return marketData !== null && marketData !== void 0 ? marketData : {\n            tokenId: walletNft.tokenId,\n            collection: {\n                id: walletNft.collectionAddress.toLowerCase()\n            },\n            nftLocation: walletNft.nftLocation,\n            metadataUrl: null,\n            transactionHistory: null,\n            currentSeller: null,\n            isTradable: null,\n            currentAskPrice: null,\n            latestTradedPriceInBNB: null,\n            tradeVolumeBNB: null,\n            totalTrades: null,\n            otherId: null\n        };\n    });\n    return walletNftsWithMarketData;\n};\n/**\n * Attach TokenMarketData and location to NftToken\n * @param nftsWithMetadata NftToken[] with API metadata\n * @param nftsForSale  market data for nfts that are on sale (i.e. not in a user's wallet)\n * @param walletNfts market data for nfts in a user's wallet\n * @param tokenIdsInWallet array of token ids in user's wallet\n * @param tokenIdsForSale array of token ids of nfts that are on sale\n * @param profileNftId profile picture token id\n * @returns NFT[]\n */ var combineNftMarketAndMetadata = function(nftsWithMetadata, nftsForSale, walletNfts, tokenIdsInWallet, tokenIdsForSale, profileNftId) {\n    var completeNftData = nftsWithMetadata.map(function(nft) {\n        // Get metadata object\n        var marketData = nftsForSale.find(function(forSaleNft) {\n            return forSaleNft.tokenId === nft.tokenId && forSaleNft.collection && forSaleNft.collection.id === nft.collectionAddress;\n        });\n        if (!marketData) {\n            marketData = walletNfts.find(function(marketNft) {\n                return marketNft.collection && marketNft.collection.id === nft.collectionAddress && marketNft.tokenId === nft.tokenId;\n            });\n        }\n        var location = getNftLocationForMarketNft(nft.tokenId, tokenIdsInWallet, tokenIdsForSale, profileNftId);\n        return (0,_object_spread_props/* default */.Z)((0,_object_spread/* default */.Z)({}, nft), {\n            marketData: marketData,\n            location: location\n        });\n    });\n    return completeNftData;\n};\nvar fetchWalletMarketData = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(walletNftsByCollection) {\n        var walletMarketDataRequests, walletMarketDataResponses;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    walletMarketDataRequests = Object.entries(walletNftsByCollection).map(function() {\n                        var _ref = (0,_async_to_generator/* default */.Z)(function(param) {\n                            var _param, collectionAddress, tokenIdsWithCollectionAddress, tokenIdIn, ref, nftsOnChainMarketData, nftsMarketData;\n                            return (0,tslib_es6.__generator)(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _param = (0,_sliced_to_array/* default */.Z)(param, 2), collectionAddress = _param[0], tokenIdsWithCollectionAddress = _param[1];\n                                        tokenIdIn = tokenIdsWithCollectionAddress.map(function(walletNft) {\n                                            return walletNft.tokenId;\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all([\n                                                getNftsOnChainMarketData(collectionAddress.toLowerCase(), tokenIdIn),\n                                                getNftsMarketData({\n                                                    tokenId_in: tokenIdIn,\n                                                    collection: collectionAddress.toLowerCase()\n                                                })\n                                            ])\n                                        ];\n                                    case 1:\n                                        ref = _sliced_to_array/* default.apply */.Z.apply(void 0, [\n                                            _state.sent(),\n                                            2\n                                        ]), nftsOnChainMarketData = ref[0], nftsMarketData = ref[1];\n                                        return [\n                                            2,\n                                            tokenIdIn.map(function(tokenId) {\n                                                var nftMarketData = nftsMarketData.find(function(tokenMarketData) {\n                                                    return tokenMarketData.tokenId === tokenId;\n                                                });\n                                                var onChainMarketData = nftsOnChainMarketData.find(function(onChainTokenMarketData) {\n                                                    return onChainTokenMarketData.tokenId === tokenId;\n                                                });\n                                                if (!nftMarketData && !onChainMarketData) return null;\n                                                return (0,_object_spread/* default */.Z)({}, nftMarketData, onChainMarketData);\n                                            }).filter(Boolean)\n                                        ];\n                                }\n                            });\n                        });\n                        return function(_) {\n                            return _ref.apply(this, arguments);\n                        };\n                    }());\n                    return [\n                        4,\n                        Promise.all(walletMarketDataRequests)\n                    ];\n                case 1:\n                    walletMarketDataResponses = _state.sent();\n                    return [\n                        2,\n                        walletMarketDataResponses.flat()\n                    ];\n            }\n        });\n    });\n    return function fetchWalletMarketData(walletNftsByCollection) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Get in-wallet, on-sale & profile pic NFT metadata, complete with market data for a given account\n * @param account\n * @param collections\n * @param profileNftWithCollectionAddress\n * @returns Promise<NftToken[]>\n */ var getCompleteAccountNftData = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(account, collections, profileNftWithCollectionAddress) {\n        var collectionsWithDelist, ref, walletNftIdsWithCollectionAddress, onChainForSaleNfts, walletNftsByCollection, walletMarketData, walletNftsWithMarketData, walletTokenIds, tokenIdsForSale, forSaleNftIds, metadataForAllNfts, completeNftData;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    collectionsWithDelist = (0,_object_spread/* default */.Z)({}, collections, delist/* default */.Z);\n                    return [\n                        4,\n                        Promise.all([\n                            fetchWalletTokenIdsForCollections(account, collectionsWithDelist),\n                            getAccountNftsOnChainMarketData(collectionsWithDelist, account)\n                        ])\n                    ];\n                case 1:\n                    ref = _sliced_to_array/* default.apply */.Z.apply(void 0, [\n                        _state.sent(),\n                        2\n                    ]), walletNftIdsWithCollectionAddress = ref[0], onChainForSaleNfts = ref[1];\n                    if (profileNftWithCollectionAddress === null || profileNftWithCollectionAddress === void 0 ? void 0 : profileNftWithCollectionAddress.tokenId) {\n                        walletNftIdsWithCollectionAddress.unshift(profileNftWithCollectionAddress);\n                    }\n                    walletNftsByCollection = groupBy_default()(walletNftIdsWithCollectionAddress, function(walletNftId) {\n                        return walletNftId.collectionAddress;\n                    });\n                    return [\n                        4,\n                        fetchWalletMarketData(walletNftsByCollection)\n                    ];\n                case 2:\n                    walletMarketData = _state.sent();\n                    walletNftsWithMarketData = attachMarketDataToWalletNfts(walletNftIdsWithCollectionAddress, walletMarketData);\n                    walletTokenIds = walletNftIdsWithCollectionAddress.filter(function(walletNft) {\n                        // Profile Pic NFT is no longer wanted in this array, hence the filter\n                        return (profileNftWithCollectionAddress === null || profileNftWithCollectionAddress === void 0 ? void 0 : profileNftWithCollectionAddress.tokenId) !== walletNft.tokenId;\n                    }).map(function(nft) {\n                        return nft.tokenId;\n                    });\n                    tokenIdsForSale = onChainForSaleNfts.map(function(nft) {\n                        return nft.tokenId;\n                    });\n                    forSaleNftIds = onChainForSaleNfts.map(function(nft) {\n                        return {\n                            collectionAddress: nft.collection.id,\n                            tokenId: nft.tokenId\n                        };\n                    });\n                    return [\n                        4,\n                        getNftsFromDifferentCollectionsApi((0,_to_consumable_array/* default */.Z)(forSaleNftIds).concat((0,_to_consumable_array/* default */.Z)(walletNftIdsWithCollectionAddress)))\n                    ];\n                case 3:\n                    metadataForAllNfts = _state.sent();\n                    completeNftData = combineNftMarketAndMetadata(metadataForAllNfts, onChainForSaleNfts, walletNftsWithMarketData, walletTokenIds, tokenIdsForSale, profileNftWithCollectionAddress === null || profileNftWithCollectionAddress === void 0 ? void 0 : profileNftWithCollectionAddress.tokenId);\n                    return [\n                        2,\n                        completeNftData\n                    ];\n            }\n        });\n    });\n    return function getCompleteAccountNftData(account, collections, profileNftWithCollectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n/**\n * Fetch distribution information for a collection\n * @returns\n */ var getCollectionDistributionApi = function() {\n    var _ref = (0,_async_to_generator/* default */.Z)(function(collectionAddress) {\n        var res, data;\n        return (0,tslib_es6.__generator)(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        fetch(\"\".concat(endpoints/* API_NFT */.C1, \"/collections/\").concat(collectionAddress, \"/distribution\"))\n                    ];\n                case 1:\n                    res = _state.sent();\n                    if (!res.ok) return [\n                        3,\n                        3\n                    ];\n                    return [\n                        4,\n                        res.json()\n                    ];\n                case 2:\n                    data = _state.sent();\n                    return [\n                        2,\n                        data\n                    ];\n                case 3:\n                    console.error(\"API: Failed to fetch NFT collection \".concat(collectionAddress, \" distribution\"), res.statusText);\n                    return [\n                        2,\n                        null\n                    ];\n            }\n        });\n    });\n    return function getCollectionDistributionApi(collectionAddress) {\n        return _ref.apply(this, arguments);\n    };\n}();\n\n\n/***/ }),\n\n/***/ 88587:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Fb\": function() { return /* binding */ NftLocation; },\n/* harmony export */   \"YG\": function() { return /* binding */ MarketEvent; },\n/* harmony export */   \"cP\": function() { return /* binding */ AskOrderType; }\n/* harmony export */ });\nvar AskOrderType;\n(function(AskOrderType) {\n    AskOrderType[\"NEW\"] = \"New\";\n    AskOrderType[\"MODIFY\"] = \"Modify\";\n    AskOrderType[\"CANCEL\"] = \"Cancel\";\n})(AskOrderType || (AskOrderType = {}));\nvar NftLocation;\n(function(NftLocation) {\n    NftLocation[\"FORSALE\"] = \"For Sale\";\n    NftLocation[\"PROFILE\"] = \"Profile Pic\";\n    NftLocation[\"WALLET\"] = \"In Wallet\";\n})(NftLocation || (NftLocation = {}));\nvar MarketEvent;\n(function(MarketEvent) {\n    MarketEvent[\"NEW\"] = \"NEW\";\n    MarketEvent[\"CANCEL\"] = \"CANCEL\";\n    MarketEvent[\"MODIFY\"] = \"MODIFY\";\n    MarketEvent[\"BUY\"] = \"BUY\";\n    MarketEvent[\"SELL\"] = \"SELL\";\n})(MarketEvent || (MarketEvent = {}));\n\n\n/***/ })\n\n}]);"],"names":["self","push","__unused_webpack_module","__webpack_exports__","active","address","avatar","banner","large","small","createdAt","creatorAddress","creatorFee","description","id","name","numberTokensListed","owner","symbol","totalSupply","totalTrades","totalVolumeBNB","tradingFee","updatedAt","verified","whitelistChecker","__webpack_require__","d","combineApiAndSgResponseToNftToken","fetchNftsFiltered","getAllPancakeBunniesLowestPrice","getAllPancakeBunniesRecentUpdatedAt","getCollection","getCollectionActivity","getCollectionDistributionApi","getCollections","getCompleteAccountNftData","getLatestListedNfts","getLeastMostPriceInCollection","getMarketDataForTokenIds","getMetadataWithFallback","getNftApi","getNftsFromCollectionApi","getNftsFromDifferentCollectionsApi","getNftsMarketData","getNftsOnChainMarketData","getNftsUpdatedMarketData","getPancakeBunniesAttributesField","getTokenActivity","getUserActivity","_async_to_generator","_object_spread","_object_spread_props","_sliced_to_array","_tagged_template_literal","_to_consumable_array","tslib_es6","dist","querystring","endpoints","multicall","utils","erc721","range","range_default","n","groupBy","groupBy_default","contractHelpers","constants","delist","market_constants","formatBalance","addressHelpers","nftMarket","fromPairs","fromPairs_default","pickBy","pickBy_default","lodash_size","size_default","types","baseNftFields","baseTransactionFields","collectionBaseFields","_templateObject","data","Z","_templateObject1","_templateObject2","_templateObject3","_templateObject4","_templateObject5","_templateObject6","_templateObject7","_templateObject8","_templateObject9","_templateObject10","_templateObject11","_ref","getCollectionsApi","res","json","__generator","_state","label","fetch","concat","C1","sent","ok","console","error","statusText","apply","arguments","fetchCollectionsTotalSupply","collections","totalSupplyCalls","totalSupplyRaw","filter","collection","map","toLowerCase","length","v","abi","calls","options","requireSuccess","flat","totalCount","toNumber","ref","collectionsMarket","ref1","collectionApiData","collectionsTotalSupply","collectionApiDataCombinedOnChain","trys","Promise","all","getCollectionsSg","combineCollectionData","index","totalSupplyFromApi","Number","totalSupplyFromOnChain","Math","max","toString","collectionAddress","collectionMarket","getCollectionApi","getCollectionSg","size","page","isPBCollection","requestPath","filteredAttributesDistribution","filteredData","filteredTotal","_arguments","UJ","J","attributesDistribution","Boolean","total","tokenId","status","from","promises","responses","nft","resp","collectionName","attributes","image","request","Bd","gql","first","skip","nfts","bunnyId","existingTokenIds","orderDirection","where","otherId","isTradable","tokenId_not_in","tokenId_in","tokenIds","nftMarketContract","response","askInfo","X$","viewAsksByCollectionAndTokenIds","tokenAskInfo","seller","price","currentSeller","Vc","currentAskPrice","dp","getAccountNftsOnChainMarketData","account","nftMarketAddress","collectionList","askCalls","askCallsResultsRaw","askCallsResults","D4","Object","values","params","askCallsResultRaw","askCallIndex","tokenIdIndex","orderBy","bunnyIds","singlePancakeBunnySubQueries","rawResponse","keys","subQueryKey","split","parseFloat","Infinity","_response","nftSg","user","askOrderHistory","buyTradeHistory","sellTradeHistory","nftActivityFilter","itemPerQuery","getAskOrderEvent","isFetchAllCollections","hasCollectionFilter","collectionFilterGql","askOrderTypeFilter","askOrderIncluded","askOrderTypeFilterGql","transactionIncluded","askOrderQueryItem","transactionQueryItem","askOrderGql","transactionGql","orderType","YG","CANCEL","cP","MODIFY","NEW","collectionFilters","JSON","stringify","typeFilters","marketEvent","SELL","some","BUY","askOrders","transactions","askHistory","transactionHistory","filters","apiMetadata","_bunnyId","original","thumbnail","traitType","value","displayType","marketData","fetchWalletTokenIdsForCollections","balanceOfCalls","balanceOfCallsResultRaw","balanceOfCallsResult","tokenIdCalls","tokenIdResultRaw","tokenIdResult","nftLocation","walletNfts","balanceOf","tokenIndex","Fb","WALLET","reduce","acc","tokenIdBn","_index","collectionSgData","collectionsMarketObj","current","fetchWalletMarketData","walletNftsByCollection","walletMarketDataRequests","walletMarketDataResponses","entries","param","_param","tokenIdsWithCollectionAddress","tokenIdIn","nftsOnChainMarketData","nftsMarketData","walletNft","nftMarketData","find","tokenMarketData","onChainMarketData","onChainTokenMarketData","_","profileNftWithCollectionAddress","collectionsWithDelist","walletNftIdsWithCollectionAddress","onChainForSaleNfts","walletMarketData","walletNftsWithMarketData","walletTokenIds","tokenIdsForSale","forSaleNftIds","metadataForAllNfts","completeNftData","marketDataForWalletNfts","nftsWithMetadata","nftsForSale","tokenIdsInWallet","profileNftId","unshift","walletNftId","marketNft","metadataUrl","latestTradedPriceInBNB","tradeVolumeBNB","forSaleNft","location","PROFILE","includes","FORSALE","AskOrderType","NftLocation","MarketEvent"],"sourceRoot":""}